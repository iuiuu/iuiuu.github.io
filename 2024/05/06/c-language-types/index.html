<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Types in C Language | Johnson Lin</title><meta name="author" content="Johnson Lin"><meta name="copyright" content="Johnson Lin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="keywords" content="Java,JVM,Spring,Spring Boot,Flink,Hadoop,Yarn,MySQL,Elasticsearch,Python,Kafka,Maven,Hbase,Kibana,Logstash,Tutorial,Technical Blogs,Data Structures,Algorithms,C,SQL,Data Science,Web Development,System Design,Interview Experience,Interview Preparation,Programming,Competitive Programming,Coding Contests,HTML,CSS,Computer Science,Programming Examples,Mathematics"><meta name="description" content="In C, every piece of data has a type that the compiler must understand to properly operate on it. The “type” refers to the shared characteristics of similar data, allowing you to know its properties a">
<meta property="og:type" content="article">
<meta property="og:title" content="Types in C Language">
<meta property="og:url" content="http://linjiangxiong.com/2024/05/06/c-language-types/index.html">
<meta property="og:site_name" content="Johnson Lin">
<meta property="og:description" content="In C, every piece of data has a type that the compiler must understand to properly operate on it. The “type” refers to the shared characteristics of similar data, allowing you to know its properties a">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://linjiangxiong.com/image/IMG_3665.JPG">
<meta property="article:published_time" content="2024-05-05T17:34:59.000Z">
<meta property="article:modified_time" content="2024-09-18T16:18:35.121Z">
<meta property="article:author" content="Johnson Lin">
<meta property="article:tag" content="C Programming Language">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://linjiangxiong.com/image/IMG_3665.JPG"><link rel="shortcut icon" href="/image/IMG_3665.JPG"><link rel="canonical" href="http://linjiangxiong.com/2024/05/06/c-language-types/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&amp;family=Source+Sans+3:wght@400;600&amp;display=swap"><link rel="stylesheet" href="/css/ud_v5.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ca45da0012a3ce293c6ca4f7e5ebc3a8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Types in C Language',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-19 00:18:35'
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/IMG_3665.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">337</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Johnson Lin</span></a><a class="nav-page-title" href="/"><span class="site-name">Types in C Language</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Types in C Language</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-05-05T17:34:59.000Z" title="Created 2024-05-06 01:34:59">2024-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-18T16:18:35.121Z" title="Updated 2024-09-19 00:18:35">2024-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Tutorial/">C Tutorial</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>In C, every piece of data has a type that the compiler must understand to properly operate on it. The “type” refers to the shared characteristics of similar data, allowing you to know its properties and operations once its type is known.</p>
<p>There are three basic data types: <code>char</code> (character), <code>int</code> (integer), and <code>float</code> (floating-point). More complex types are built from these.</p>
<h2 id="Character-Type"><a href="#Character-Type" class="headerlink" title="Character Type"></a>Character Type</h2><p>The character type represents a single character and is declared with the <code>char</code> keyword.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>In this example, <code>c</code> is declared as a character type and assigned the value ‘B’. In C, character constants must be enclosed in single quotes.</p>
<p>Internally, characters are stored in one byte (8 bits). C treats them as integers, so a character is essentially an integer with a width of one byte. Each character corresponds to an integer (defined by the ASCII code), with ‘B’ corresponding to the integer 66.</p>
<p>Different systems may have different default ranges for the <code>char</code> type. Some systems use -128 to 127, while others use 0 to 255. Both ranges cover the ASCII range of 0 to 127.</p>
<p>Integers within the <code>char</code> range can be used interchangeably with characters and assigned to <code>char</code> variables.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">66</span>;</span><br><span class="line"><span class="comment">// Equivalent to</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>In this example, assigning 66 to <code>c</code> has the same effect as assigning ‘B’.</p>
<p>Character variables can also participate in arithmetic operations.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;B&#x27;</span>; <span class="comment">// Equivalent to char a = 66;</span></span><br><span class="line"><span class="type">char</span> b = <span class="string">&#x27;C&#x27;</span>; <span class="comment">// Equivalent to char b = 67;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b); <span class="comment">// Outputs 133</span></span><br></pre></td></tr></table></figure>
<p>Here, adding <code>a</code> and <code>b</code> is treated like adding two integers, and <code>%d</code> prints the result as a decimal integer, yielding 133.</p>
<p>Single quotes themselves are characters, so to represent a single quote in a character constant, you need to escape it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> t = <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>In this case, <code>t</code> holds the single quote character. Since character constants must be in single quotes, the internal single quote needs to be escaped.</p>
<p>Escape sequences are also used to represent unprintable control characters, which are part of the character type values:</p>
<ul>
<li><code>\a</code>: Alert (causes an alert sound or visual flash)</li>
<li><code>\b</code>: Backspace (moves the cursor back one character without deleting it)</li>
<li><code>\f</code>: Form feed (moves the cursor to the next page; in modern systems, it behaves like <code>\v</code>)</li>
<li><code>\n</code>: Newline</li>
<li><code>\r</code>: Carriage return (moves the cursor to the start of the line)</li>
<li><code>\t</code>: Horizontal tab (moves the cursor to the next tab stop, usually every 8 characters)</li>
<li><code>\v</code>: Vertical tab (moves the cursor to the next vertical tab stop, usually the same column on the next line)</li>
<li><code>\0</code>: Null character (represents no content; different from the number 0)</li>
</ul>
<p>Escape sequences can also use octal and hexadecimal notation:</p>
<ul>
<li><code>\nn</code>: Octal representation of the character, where <code>nn</code> is the octal value</li>
<li><code>\xnn</code>: Hexadecimal representation of the character, where <code>nn</code> is the hexadecimal value</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="type">char</span> x = <span class="number">66</span>;</span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;\102&#x27;</span>; <span class="comment">// Octal</span></span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;\x42&#x27;</span>; <span class="comment">// Hexadecimal</span></span><br></pre></td></tr></table></figure>
<p>All four of these declarations are equivalent.</p>
<h2 id="Integer-Types"><a href="#Integer-Types" class="headerlink" title="Integer Types"></a>Integer Types</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>In C, integer types are used to represent whole numbers. The type is declared using the <code>int</code> keyword.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p>In the example above, an integer variable <code>a</code> is declared.</p>
<p>The size of the <code>int</code> type can vary between different computers. Commonly, an <code>int</code> is stored in 4 bytes (32 bits), but it can also be 2 bytes (16 bits) or 8 bytes (64 bits). The ranges of integers that these types can represent are as follows:</p>
<ul>
<li><strong>16-bit</strong>: -32,768 to 32,767</li>
<li><strong>32-bit</strong>: -2,147,483,648 to 2,147,483,647</li>
<li><strong>64-bit</strong>: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</li>
</ul>
<h3 id="Signed-and-Unsigned"><a href="#Signed-and-Unsigned" class="headerlink" title="Signed and Unsigned"></a>Signed and Unsigned</h3><p>In C, the <code>signed</code> keyword indicates that a type can hold both positive and negative values. Conversely, the <code>unsigned</code> keyword means the type can only hold zero and positive values.</p>
<p>By default, <code>int</code> is signed, which means <code>int</code> is equivalent to <code>signed int</code>. Although the <code>signed</code> keyword is usually omitted, it is not incorrect to include it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> a;  <span class="comment">// Equivalent to</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p>To declare an <code>int</code> without a sign (only non-negative values), use the <code>unsigned</code> keyword:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p>An <code>unsigned int</code> can represent a larger maximum value compared to a signed <code>int</code> of the same size. For instance, a 16-bit <code>signed int</code> has a maximum value of 32,767, while an <code>unsigned int</code> can go up to 65,535.</p>
<p>The <code>int</code> in <code>unsigned int</code> can be omitted:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a;</span><br></pre></td></tr></table></figure>
<p>The <code>char</code> type can also be signed or unsigned:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> c;    <span class="comment">// Range: -128 to 127</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c;  <span class="comment">// Range: 0 to 255</span></span><br></pre></td></tr></table></figure>
<p>Note that the default sign of <code>char</code> (whether it is signed or unsigned) is system-dependent. Unlike <code>int</code>, <code>char</code> is not guaranteed to be signed or unsigned.</p>
<h3 id="Integer-Subtypes"><a href="#Integer-Subtypes" class="headerlink" title="Integer Subtypes"></a>Integer Subtypes</h3><p>When an <code>int</code> type uses 4 or 8 bytes, it may be overkill for small integers. On the other hand, if larger integers are needed, 8 bytes might not be sufficient. To address these issues, C provides three subtypes of integers, allowing for more precise control over the integer range:</p>
<ul>
<li><strong>short int</strong> (or <code>short</code>): Uses no more than <code>int</code>, generally 2 bytes (range: -32,768 to 32,767)</li>
<li><strong>long int</strong> (or <code>long</code>): Uses at least as much space as <code>int</code>, generally 4 bytes</li>
<li><strong>long long int</strong> (or <code>long long</code>): Uses more space than <code>long</code>, at least 8 bytes</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> c;</span><br></pre></td></tr></table></figure>
<p>By default, <code>short</code>, <code>long</code>, and <code>long long</code> are signed. You can declare them as unsigned to double the maximum value they can represent:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> c;</span><br></pre></td></tr></table></figure>
<p>The <code>int</code> in these declarations can be omitted:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> b;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> c;</span><br></pre></td></tr></table></figure>
<p>The size of data types can vary between computers. Use <code>long</code> for 32-bit integers and <code>long long</code> for 64-bit integers to ensure proper size, and use <code>short</code> for 16-bit integers. For 8-bit integers, use <code>char</code>.</p>
<h3 id="Limits-of-Integer-Types"><a href="#Limits-of-Integer-Types" class="headerlink" title="Limits of Integer Types"></a>Limits of Integer Types</h3><p>To determine the maximum and minimum values of integer types on your system, use constants from the header file <code>limits.h</code>. For example:</p>
<ul>
<li><code>SCHAR_MIN</code> and <code>SCHAR_MAX</code> for <code>signed char</code></li>
<li><code>SHRT_MIN</code> and <code>SHRT_MAX</code> for <code>short</code></li>
<li><code>INT_MIN</code> and <code>INT_MAX</code> for <code>int</code></li>
<li><code>LONG_MIN</code> and <code>LONG_MAX</code> for <code>long</code></li>
<li><code>LLONG_MIN</code> and <code>LLONG_MAX</code> for <code>long long</code></li>
<li><code>UCHAR_MAX</code> for <code>unsigned char</code></li>
<li><code>USHRT_MAX</code> for <code>unsigned short</code></li>
<li><code>UINT_MAX</code> for <code>unsigned int</code></li>
<li><code>ULONG_MAX</code> for <code>unsigned long</code></li>
<li><code>ULLONG_MAX</code> for <code>unsigned long long</code></li>
</ul>
<p>Using these constants ensures your code remains portable across different systems.</p>
<h3 id="Integer-Literals-and-Formats"><a href="#Integer-Literals-and-Formats" class="headerlink" title="Integer Literals and Formats"></a>Integer Literals and Formats</h3><p>By default, integers in C are written in decimal. To represent octal and hexadecimal numbers, use specific prefixes:</p>
<ul>
<li><strong>Octal</strong>: Prefix with <code>0</code> (e.g., <code>017</code> or <code>0377</code>).</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">012</span>;  <span class="comment">// Octal, equivalent to decimal 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Hexadecimal</strong>: Prefix with <code>0x</code> or <code>0X</code> (e.g., <code>0xf</code> or <code>0X10</code>).</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x1A2B</span>;  <span class="comment">// Hexadecimal, equivalent to decimal 6699</span></span><br></pre></td></tr></table></figure>
<p>Some compilers also support binary literals with the <code>0b</code> prefix (though this is not standard):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0b101010</span>;</span><br></pre></td></tr></table></figure>
<p>Different bases are only for representation; they do not affect the actual storage of the integer, which is always in binary. You can mix bases in expressions, such as <code>10 + 015 + 0x20</code>.</p>
<p>Use the following format specifiers with <code>printf()</code> to display integers in different bases:</p>
<ul>
<li><code>%d</code>: Decimal</li>
<li><code>%o</code>: Octal</li>
<li><code>%x</code>: Hexadecimal</li>
<li><code>%#o</code>: Octal with prefix <code>0</code></li>
<li><code>%#x</code>: Hexadecimal with prefix <code>0x</code></li>
<li><code>%#X</code>: Hexadecimal with prefix <code>0X</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dec = %d\n&quot;</span>, x);       <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;octal = %o\n&quot;</span>, x);     <span class="comment">// 144</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %x\n&quot;</span>, x);       <span class="comment">// 64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;octal = %#o\n&quot;</span>, x);    <span class="comment">// 0144</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %#x\n&quot;</span>, x);      <span class="comment">// 0x64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %#X\n&quot;</span>, x);      <span class="comment">// 0X64</span></span><br></pre></td></tr></table></figure>
<h2 id="Floating-Point-Numbers"><a href="#Floating-Point-Numbers" class="headerlink" title="Floating Point Numbers"></a>Floating Point Numbers</h2><p>In programming, a floating point number is a value with a decimal point, represented in the form ( $ m \times b^e $ ), where ( <code>m</code> ) is the mantissa, ( <code>b</code> ) is the base (usually <code>2</code>), and ( <code>e</code> ) is the exponent. This format balances precision and range, allowing for representation of very large or very small numbers.</p>
<p>In C, floating point types are declared using the <code>float</code> keyword. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> c = <span class="number">10.5</span>;</span><br></pre></td></tr></table></figure>
<p>Here, <code>c</code> is a floating point variable. The <code>float</code> type uses 4 bytes (32 bits), with 8 bits for the exponent and sign, and 24 bits for the mantissa and sign. It provides at least 6 decimal digits of precision and can represent values from $ 10^{-37} $ to $ 10^{37} $.</p>
<p>For cases where more precision or range is needed, C offers two larger floating point types:</p>
<ul>
<li><code>double</code>: Uses 8 bytes (64 bits), with at least 13 decimal digits of precision.</li>
<li><code>long double</code>: Typically uses 16 bytes, but this can vary by system.</li>
</ul>
<p>Due to precision limits, floating point numbers are approximations, and calculations may not be exact. For example, in C, <code>0.1 + 0.2</code> does not exactly equal <code>0.3</code>, but has a small error:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>Floating point numbers can also be represented using scientific notation, where <code>e</code> separates the decimal part from the exponent:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">123.456e+3</span>; <span class="comment">// Equivalent to 123.456 x 10^3</span></span><br><span class="line"><span class="comment">// or simply</span></span><br><span class="line"><span class="type">double</span> x = <span class="number">123.456e3</span>;</span><br></pre></td></tr></table></figure>
<p>The <code>+</code> in the exponent can be omitted, and spaces around <code>e</code> are not allowed. Leading or trailing zeros in the decimal part can be omitted:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.3E6</span> <span class="comment">// Equivalent to .3E6</span></span><br><span class="line"><span class="number">3.0E6</span> <span class="comment">// Equivalent to 3.E6</span></span><br></pre></td></tr></table></figure>
<h2 id="Boolean-Type"><a href="#Boolean-Type" class="headerlink" title="Boolean Type"></a>Boolean Type</h2><p>Originally, C did not have a dedicated boolean type. Instead, <code>0</code> was used for false, and any non-zero value was considered true:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x is true!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With the C99 standard, <code>_Bool</code> was introduced to represent boolean values. This is essentially an alias for <code>int</code>, with <code>0</code> as false and <code>1</code> as true:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> isNormal;</span><br><span class="line">isNormal = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (isNormal)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Everything is OK.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>The header file <code>stdbool.h</code> defines a <code>bool</code> type alias and constants <code>true</code> and <code>false</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Literal-types"><a href="#Literal-types" class="headerlink" title="Literal types"></a>Literal types</h2><p>Literals are fixed values directly written into the code.</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>In this code, <code>x</code> is a variable, and <code>123</code> is a literal.</p>
<p>At compile time, literals are also written to memory, so the compiler must assign a data type to them just as it does for variables.</p>
<p>Typically, decimal integer literals (like <code>123</code>) are assigned the <code>int</code> type by the compiler. If a number is too large for an <code>int</code>, the compiler assigns it <code>long int</code>. If it exceeds <code>long int</code>, it will be assigned <code>unsigned long</code>, and if that’s still not sufficient, it will be assigned <code>long long</code> or <code>unsigned long long</code>.</p>
<p>Floating-point literals (like <code>3.14</code>) are assigned the <code>double</code> type.</p>
<h2 id="Literal-Suffixes"><a href="#Literal-Suffixes" class="headerlink" title="Literal Suffixes"></a>Literal Suffixes</h2><p>Sometimes, programmers want to specify a different type for a literal. For instance, the compiler assigns an integer literal to the <code>int</code> type by default, but if a programmer wants to assign it as a <code>long</code>, they can add the suffix <code>l</code> or <code>L</code> to the literal. This signals to the compiler to treat the literal as a <code>long</code> type.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123L</span>;</span><br></pre></td></tr></table></figure>
<p>In the above example, the literal <code>123</code> has the suffix <code>L</code>, so the compiler will treat it as a <code>long</code>. You can also write it as <code>123l</code>, but using <code>L</code> is recommended because the lowercase <code>l</code> can be easily confused with the number <code>1</code>.</p>
<p>Octal and hexadecimal values can also use the <code>l</code> or <code>L</code> suffix to indicate they should be treated as <code>long</code>, such as <code>020L</code> and <code>0x20L</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">0377L</span>;</span><br><span class="line"><span class="type">int</span> z = <span class="number">0x7fff</span>L;</span><br></pre></td></tr></table></figure>
<p>If you want to specify an unsigned integer, use the suffix <code>u</code> or <code>U</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123U</span>;</span><br></pre></td></tr></table></figure>
<p>The <code>L</code> and <code>U</code> suffixes can be combined to indicate an <code>unsigned long</code>. The order and case of <code>L</code> and <code>U</code> do not matter.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123LU</span>;</span><br></pre></td></tr></table></figure>
<p>For floating-point numbers, the compiler defaults to the <code>double</code> type. If you want to specify a different type, add the suffix <code>f</code> (for <code>float</code>) or <code>l</code> (for <code>long double</code>) after the decimal.</p>
<p>You can also use suffixes with scientific notation.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.2345e+10</span>F</span><br><span class="line"><span class="number">1.2345e+10</span>L</span><br></pre></td></tr></table></figure>
<p>To summarize, here are the common literal suffixes:</p>
<ul>
<li><code>f</code> and <code>F</code>: <code>float</code> type.</li>
<li><code>l</code> and <code>L</code>: <code>long int</code> for integers, <code>long double</code> for floating-point numbers.</li>
<li><code>ll</code> and <code>LL</code>: <code>long long int</code>, such as <code>3LL</code>.</li>
<li><code>u</code> and <code>U</code>: <code>unsigned int</code>, such as <code>15U</code> or <code>0377U</code>.</li>
<li><code>u</code> can be combined with other integer suffixes, and the order doesn’t matter, e.g., <code>10UL</code>, <code>10ULL</code>, and <code>10LLU</code> are all valid.</li>
</ul>
<p>Here are some examples:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>           x = <span class="number">1234</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span>      x = <span class="number">1234L</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x = <span class="number">1234LL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>           x = <span class="number">1234U</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>      x = <span class="number">1234UL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x = <span class="number">1234ULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> x       = <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">double</span> x      = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> x = <span class="number">3.14L</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h2><p>Each data type has a defined range of values. If a value exceeds this range (either smaller than the minimum or larger than the maximum), an overflow occurs, requiring more binary space than available. If the value exceeds the maximum, it’s called an <strong>overflow</strong>; if it’s smaller than the minimum, it’s an <strong>underflow</strong>.</p>
<p>Generally, the compiler won’t throw an error for overflows. Instead, it will execute the code and discard the excess binary bits, leading to unexpected results. Therefore, overflows should be avoided.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x = <span class="number">255</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// Output: 0</span></span><br></pre></td></tr></table></figure>
<p>In this example, adding <code>1</code> to <code>x</code> doesn’t result in <code>256</code>, but rather <code>0</code>. This happens because <code>x</code> is an <code>unsigned char</code> with a maximum value of <code>255</code> (binary <code>11111111</code>). Adding <code>1</code> causes an overflow, and the highest bit in <code>256</code> (binary <code>100000000</code>) is discarded, leaving <code>0</code>.</p>
<p>Here’s another example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = UINT_MAX;  <span class="comment">// 4,294,967,295</span></span><br><span class="line">ui++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 0</span></span><br><span class="line">ui--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 4,294,967,295</span></span><br></pre></td></tr></table></figure>
<p>The constant <code>UINT_MAX</code> is the maximum value for <code>unsigned int</code>. Adding <code>1</code> causes an overflow, resulting in <code>0</code>. Subtracting <code>1</code> from <code>0</code> returns <code>UINT_MAX</code>.</p>
<p>Overflows are easy to overlook because the compiler won’t issue warnings, so extra caution is needed.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>At first glance, this loop looks fine, but the variable <code>i</code> is an <code>unsigned int</code>, and its minimum value is <code>0</code>. It cannot produce a value less than <code>0</code>. When <code>i</code> reaches <code>0</code> and is decremented by <code>1</code>, it doesn’t result in <code>-1</code>, but rather the maximum value for <code>unsigned int</code>, which is always greater than or equal to <code>0</code>, leading to an infinite loop.</p>
<p>To prevent overflows, the best approach is to compare the result of an operation with the limits of the data type.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Incorrect</span></span><br><span class="line"><span class="keyword">if</span> (sum + ui &gt; UINT_MAX) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (ui &gt; UINT_MAX - sum) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br></pre></td></tr></table></figure>
<p>In the above example, both <code>sum</code> and <code>ui</code> are of <code>unsigned int</code> type, and their sum might cause an overflow. However, you cannot determine an overflow by checking if the sum exceeds <code>UINT_MAX</code>, because <code>sum + ui</code> returns the overflowed result, which cannot be greater than <code>UINT_MAX</code>. The correct method is to compare <code>UINT_MAX - sum</code> with <code>ui</code>.</p>
<p>Here’s another common mistake:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i - j &lt; <span class="number">0</span>) <span class="comment">// Error</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;negative\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;positive\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>The above code will always print <code>positive</code>. This is because both <code>i</code> and <code>j</code> are <code>unsigned int</code>, so the result of <code>i - j</code> is also <code>unsigned int</code>, which has a minimum value of <code>0</code>. It cannot be less than <code>0</code>. The correct way to write this is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &gt; i) <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="sizeof-Operator"><a href="#sizeof-Operator" class="headerlink" title="sizeof Operator"></a><code>sizeof</code> Operator</h2><p>The <code>sizeof</code> operator in C is used to determine the number of bytes occupied by a data type or a specific value. Its argument can be a data type keyword, a variable, or a literal value.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Argument as data type</span></span><br><span class="line"><span class="type">int</span> x = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument as a variable</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">sizeof</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument as a literal</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure>
<p>In the first example, <code>sizeof(int)</code> returns the number of bytes used by the <code>int</code> type (typically 4 or 8 bytes). The second example returns the size of the integer variable <code>i</code>, which will be the same as the first. The third example returns the size of the literal <code>3.14</code>, which is treated as a <code>double</code> by default, so it returns 8.</p>
<p>The return type of <code>sizeof</code> is an unsigned integer, but C does not mandate its specific type—it varies by system. It could be <code>unsigned int</code>, <code>unsigned long</code>, or even <code>unsigned long long</code>, and the corresponding <code>printf()</code> format specifiers are <code>%u</code>, <code>%lu</code>, and <code>%llu</code> respectively. This variability can impact the portability of programs across different systems.</p>
<p>To solve this, C provides the <code>size_t</code> type, defined in the <code>stddef.h</code> header (included automatically with <code>stdio.h</code>), which represents the return type of <code>sizeof</code> across different systems. This helps ensure portability.</p>
<p>C also provides the constant <code>SIZE_MAX</code>, which represents the maximum value that <code>size_t</code> can hold. The valid range for <code>size_t</code> is [0, SIZE_MAX].</p>
<p>For <code>printf()</code>, the specifiers <code>%zd</code> or <code>%zu</code> are specifically designed to handle <code>size_t</code> values.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>In this example, <code>%zd</code> ensures correct output regardless of the underlying type returned by <code>sizeof</code>. If your system doesn’t support <code>%zd</code> or <code>%zu</code>, you can use <code>%u</code> for <code>unsigned int</code> or <code>%lu</code> for <code>unsigned long</code>.</p>
<h2 id="Automatic-Type-Conversion"><a href="#Automatic-Type-Conversion" class="headerlink" title="Automatic Type Conversion"></a>Automatic Type Conversion</h2><p>In certain situations, C automatically converts one data type to another.</p>
<h3 id="Assignment-Operations"><a href="#Assignment-Operations" class="headerlink" title="Assignment Operations"></a>Assignment Operations</h3><ol>
<li><strong>Assigning a floating-point value to an integer variable</strong><br>When assigning a floating-point value to an integer, C discards the fractional part rather than rounding.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>In this example, the value assigned to <code>x</code> is <code>3</code>, as the fractional part <code>.14</code> is discarded.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">12.99</span>;</span><br></pre></td></tr></table></figure>
<p>Here, <code>x</code> becomes <code>12</code>, not the rounded value <code>13</code>.</p>
<ol>
<li><strong>Assigning an integer value to a floating-point variable</strong><br>When assigning an integer to a floating-point variable, C automatically converts the integer to a float.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> y = <span class="number">12</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>The value of <code>y</code> is <code>24.0</code> because the integer result <code>24</code> is automatically converted to a floating-point number.</p>
<ol>
<li><strong>Assigning a smaller type to a larger type</strong><br>When assigning a value of a narrower type (like <code>char</code>) to a wider type (like <code>int</code>), the value is automatically promoted to the larger type.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i = x + y;</span><br></pre></td></tr></table></figure>
<p>Here, <code>x</code> is promoted to <code>int</code> before the operation.</p>
<ol>
<li><strong>Assigning a larger type to a smaller type</strong><br>When assigning a larger type (like <code>int</code>) to a smaller type (like <code>char</code>), truncation occurs, and excess bits are discarded.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">321</span>;</span><br><span class="line"><span class="type">char</span> ch = i;  <span class="comment">// ch holds 65, which is 321 % 256</span></span><br></pre></td></tr></table></figure>
<p>In this example, <code>ch</code> stores <code>65</code> because the excess binary digits of <code>321</code> are discarded, leaving only the last 8 bits (which represent <code>65</code> in decimal).</p>
<p>Similarly, assigning a floating-point value to an integer variable truncates the decimal part.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> i = pi;  <span class="comment">// i becomes 3</span></span><br></pre></td></tr></table></figure>
<h3 id="Mixed-Type-Operations"><a href="#Mixed-Type-Operations" class="headerlink" title="Mixed-Type Operations"></a>Mixed-Type Operations</h3><p>When different types are mixed in an expression, C converts them to a common type before performing the operation:</p>
<ol>
<li><strong>Integer and floating-point operations</strong><br>In operations involving both integers and floating-point values, integers are converted to floating-point types.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">1.2</span>  <span class="comment">// Result: 4.2</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>Floating-point type promotion</strong><br>When performing operations between different floating-point types, the smaller type is promoted to the larger type (e.g., <code>float</code> to <code>double</code>).</li>
<li><strong>Integer type promotion</strong><br>For integer operations, smaller integer types are promoted to larger types (e.g., <code>short</code> to <code>int</code>).</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-5</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="keyword">sizeof</span>(<span class="type">int</span>)) </span><br><span class="line">  do_something();</span><br></pre></td></tr></table></figure>
<p>Here, <code>a</code> is a signed integer, and <code>sizeof(int)</code> returns an unsigned integer (<code>size_t</code>). C automatically converts <code>a</code> to an unsigned type, which leads to an unexpected comparison result.</p>
<h3 id="Integer-Operations"><a href="#Integer-Operations" class="headerlink" title="Integer Operations"></a>Integer Operations</h3><p>For integer types smaller than <code>int</code>, arithmetic results are promoted to <code>int</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">66</span>;</span><br><span class="line"><span class="keyword">if</span> (-a &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;negative\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>In this example, <code>-a</code> is promoted to <code>int</code>, so the result is negative even though <code>a</code> is <code>unsigned char</code>.</p>
<p>Another example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">if</span> ((a - <span class="number">5</span>) &lt; <span class="number">0</span>) do_something();</span><br><span class="line"><span class="keyword">if</span> ((b + <span class="number">255</span>) &gt; <span class="number">300</span>) do_something();</span><br></pre></td></tr></table></figure>
<p>In both cases, the expressions are promoted to <code>int</code>, so the operations execute as expected.</p>
<h3 id="Function-Parameter-and-Return-Type-Conversion"><a href="#Function-Parameter-and-Return-Type-Conversion" class="headerlink" title="Function Parameter and Return Type Conversion"></a>Function Parameter and Return Type Conversion</h3><p>Function parameters and return values are automatically converted to match the function’s defined types.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dostuff</span><span class="params">(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">char</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> m = <span class="number">42</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n = <span class="number">43</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c = dostuff(m, n);</span><br></pre></td></tr></table></figure>
<p>In this case, <code>m</code> and <code>n</code> are converted to <code>int</code> and <code>unsigned char</code> respectively, matching the function’s signature.</p>
<p>Similarly, return values are automatically converted:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, the function returns a <code>char</code>, so the <code>int</code> variable <code>a</code> is converted accordingly.</p>
<h2 id="Explicit-Type-Casting"><a href="#Explicit-Type-Casting" class="headerlink" title="Explicit Type Casting"></a>Explicit Type Casting</h2><p>In principle, automatic type conversion should be avoided to prevent unexpected results. C provides explicit type casting, allowing you to manually convert a value to a specified type.</p>
<p>To cast a value or variable, simply place the desired type in parentheses before the value or variable. This is called “type casting.”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>) ch</span><br></pre></td></tr></table></figure>
<p>The example above casts the variable <code>ch</code> to an unsigned character type.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> y = (<span class="type">long</span> <span class="type">int</span>) <span class="number">10</span> + <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>In this example, <code>(long int)</code> explicitly converts <code>10</code> to a <code>long int</code>. However, this cast is unnecessary because the assignment operator will automatically convert the right-hand value to the type of the left-hand variable.</p>
<h2 id="Portable-Data-Types"><a href="#Portable-Data-Types" class="headerlink" title="Portable Data Types"></a>Portable Data Types</h2><p>The width of C’s integer types (<code>short</code>, <code>int</code>, <code>long</code>) can vary across different machines, making it difficult to predict how many bytes these types will occupy. To write more portable code, programmers can control the exact width of integers. The header file <code>stdint.h</code> provides type aliases for this purpose.</p>
<ol>
<li><strong>Exact-width integer types</strong> guarantee the size of an integer:<ul>
<li><code>int8_t</code>: 8-bit signed integer.</li>
<li><code>int16_t</code>: 16-bit signed integer.</li>
<li><code>int32_t</code>: 32-bit signed integer.</li>
<li><code>int64_t</code>: 64-bit signed integer.</li>
<li><code>uint8_t</code>: 8-bit unsigned integer.</li>
<li><code>uint16_t</code>: 16-bit unsigned integer.</li>
<li><code>uint32_t</code>: 32-bit unsigned integer.</li>
<li><code>uint64_t</code>: 64-bit unsigned integer.</li>
</ul>
</li>
</ol>
<p>These are type aliases that the compiler maps to the appropriate underlying type. For example, if <code>int</code> is 32 bits on a given system, <code>int32_t</code> will map to <code>int</code>. If <code>long</code> is 32 bits, <code>int32_t</code> will map to <code>long</code>.</p>
<p>Example usage:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> x32 = <span class="number">45933945</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x32 = %d\n&quot;</span>, x32);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this example, <code>x32</code> is declared as an <code>int32_t</code>, ensuring a width of 32 bits.</p>
<ol>
<li><strong>Minimum-width types</strong> guarantee a minimum number of bits:<ul>
<li><code>int_least8_t</code></li>
<li><code>int_least16_t</code></li>
<li><code>int_least32_t</code></li>
<li><code>int_least64_t</code></li>
<li><code>uint_least8_t</code></li>
<li><code>uint_least16_t</code></li>
<li><code>uint_least32_t</code></li>
<li><code>uint_least64_t</code></li>
</ul>
</li>
</ol>
<p>These types ensure that the integer occupies at least the specified number of bits. For example, <code>int_least8_t</code> is guaranteed to be at least 8 bits wide.</p>
<ol>
<li><strong>Fastest minimum-width types</strong> ensure the fastest integer operations for a given width:<ul>
<li><code>int_fast8_t</code></li>
<li><code>int_fast16_t</code></li>
<li><code>int_fast32_t</code></li>
<li><code>int_fast64_t</code></li>
<li><code>uint_fast8_t</code></li>
<li><code>uint_fast16_t</code></li>
<li><code>uint_fast32_t</code></li>
<li><code>uint_fast64_t</code></li>
</ul>
</li>
</ol>
<p>These types guarantee both the width and the fastest operation speed. For instance, <code>int_fast8_t</code> represents the fastest type for storing an 8-bit signed integer. On some machines, processing 32-bit integers may be faster than processing 16-bit integers, so the fastest type might be larger than 8 bits.</p>
<ol>
<li><strong>Pointer-sized integer types</strong> store pointers as integers:<ul>
<li><code>intptr_t</code>: A signed integer capable of holding a pointer (memory address).</li>
<li><code>uintptr_t</code>: An unsigned integer capable of holding a pointer.</li>
</ul>
</li>
</ol>
<ol>
<li><strong>Maximum-width integer types</strong> store the largest possible integers:<ul>
<li><code>intmax_t</code>: Can store any valid signed integer.</li>
<li><code>uintmax_t</code>: Can store any valid unsigned integer.</li>
</ul>
</li>
</ol>
<p>These types can store larger integers than <code>long long</code> and <code>unsigned long</code>.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com">Johnson Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com/2024/05/06/c-language-types/">http://linjiangxiong.com/2024/05/06/c-language-types/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Programming-Language/">C Programming Language</a></div><div class="post-share"><div class="social-share" data-image="/image/IMG_3665.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/05/07/c-language-pointer/" title="Pointer in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Pointer in C Language</div></div><div class="info-2"><div class="info-item-1">Pointers are one of the most important and challenging concepts in the C programming language. OverviewWhat is a pointer? In essence, it’s a value representing a memory address, acting as a signpost to a specific location in memory. The asterisk * represents a pointer and is usually placed after the type keyword to indicate what type of value the pointer is referencing. For example, char* is a pointer to a character, and float* is a pointer to a float. 1int* intPtr; The above example...</div></div></div></a><a class="pagination-related" href="/2024/05/05/c-language-flow-control/" title="Flow Control in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Flow Control in C Language</div></div><div class="info-2"><div class="info-item-1">In C programming, execution is sequential, meaning statements are executed one after the other. To control the flow of execution, developers use flow control structures, primarily conditional and loop statements. if StatementThe if statement is used for conditional execution; it executes a specified statement if the condition is true. Syntax: 1if (expression) statement Here, expression must be true (non-zero) for statement to execute. The condition inside the parentheses must be enclosed in...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/05/01/introduction-to-the-c-language/" title="Introduction to the C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-01</div><div class="info-item-2">Introduction to the C Language</div></div><div class="info-2"><div class="info-item-1">HistoryThe C programming language was originally invented as a tool for developing the Unix operating system. In 1969, Ken Thompson and Dennis Ritchie at Bell Labs in the United States developed the Unix operating system. Unix was initially written in assembly language, making it difficult to port to other computers. To address this, they decided to rewrite it in a high-level language. However, existing high-level languages at the time did not meet their needs, so Thompson developed the B...</div></div></div></a><a class="pagination-related" href="/2024/05/02/basic-c-language-syntax/" title="Basic C Language Syntax"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-02</div><div class="info-item-2">Basic C Language Syntax</div></div><div class="info-2"><div class="info-item-1">StatementsC code is composed of statements. A statement is a command that the program executes. In C, each statement must end with a semicolon, unless specified otherwise. 1int x = 1; The above is a variable declaration statement, where the integer variable x is declared and assigned a value of 1. Multiple statements can be written on a single line: 1int x; x = 1; Here, two statements are written on one line. Line breaks between statements aren’t required but are often used for...</div></div></div></a><a class="pagination-related" href="/2024/05/03/c-language-variables/" title="Understanding Variables in C Programming"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="info-item-2">Understanding Variables in C Programming</div></div><div class="info-2"><div class="info-item-1"> A variable can be understood as the name of a memory location. By using the variable name, you can reference this memory and access the stored value. The value might change, which is why it’s called a variable. If the value remains constant, it’s referred to as a constant. Variable NamesIn C, variable names are considered identifiers, and there are strict rules for naming them:  They can only contain letters (both uppercase and lowercase), digits, and underscores (_). They cannot begin with...</div></div></div></a><a class="pagination-related" href="/2024/05/04/c-language-operator/" title="Operators in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">Operators in C Language</div></div><div class="info-2"><div class="info-item-1">C language includes a wide variety of operators, more than 50 in total, which can be categorized into several types. Arithmetic OperatorsArithmetic operators are used for mathematical operations. The main ones are as follows:  +: Unary plus (positive sign)   -: Unary minus (negative sign)   +: Addition (binary operator)   -: Subtraction (binary operator)   *: Multiplication   /: Division   %: Modulus (remainder of division)   Unary + and -:The + and - can act as unary operators, requiring...</div></div></div></a><a class="pagination-related" href="/2024/05/05/c-language-flow-control/" title="Flow Control in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-05</div><div class="info-item-2">Flow Control in C Language</div></div><div class="info-2"><div class="info-item-1">In C programming, execution is sequential, meaning statements are executed one after the other. To control the flow of execution, developers use flow control structures, primarily conditional and loop statements. if StatementThe if statement is used for conditional execution; it executes a specified statement if the condition is true. Syntax: 1if (expression) statement Here, expression must be true (non-zero) for statement to execute. The condition inside the parentheses must be enclosed in...</div></div></div></a><a class="pagination-related" href="/2024/05/07/c-language-pointer/" title="Pointer in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-07</div><div class="info-item-2">Pointer in C Language</div></div><div class="info-2"><div class="info-item-1">Pointers are one of the most important and challenging concepts in the C programming language. OverviewWhat is a pointer? In essence, it’s a value representing a memory address, acting as a signpost to a specific location in memory. The asterisk * represents a pointer and is usually placed after the type keyword to indicate what type of value the pointer is referencing. For example, char* is a pointer to a character, and float* is a pointer to a float. 1int* intPtr; The above example...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/IMG_3665.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Johnson Lin</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">337</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iuiuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/iuiuu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:me@linjiangxiong.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Character-Type"><span class="toc-number">1.</span> <span class="toc-text">Character Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer-Types"><span class="toc-number">2.</span> <span class="toc-text">Integer Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview"><span class="toc-number">2.1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Signed-and-Unsigned"><span class="toc-number">2.2.</span> <span class="toc-text">Signed and Unsigned</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-Subtypes"><span class="toc-number">2.3.</span> <span class="toc-text">Integer Subtypes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Limits-of-Integer-Types"><span class="toc-number">2.4.</span> <span class="toc-text">Limits of Integer Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-Literals-and-Formats"><span class="toc-number">2.5.</span> <span class="toc-text">Integer Literals and Formats</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Floating-Point-Numbers"><span class="toc-number">3.</span> <span class="toc-text">Floating Point Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boolean-Type"><span class="toc-number">4.</span> <span class="toc-text">Boolean Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Literal-types"><span class="toc-number">5.</span> <span class="toc-text">Literal types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Literal-Suffixes"><span class="toc-number">6.</span> <span class="toc-text">Literal Suffixes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overflow"><span class="toc-number">7.</span> <span class="toc-text">Overflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof-Operator"><span class="toc-number">8.</span> <span class="toc-text">sizeof Operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Automatic-Type-Conversion"><span class="toc-number">9.</span> <span class="toc-text">Automatic Type Conversion</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Assignment-Operations"><span class="toc-number">9.1.</span> <span class="toc-text">Assignment Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixed-Type-Operations"><span class="toc-number">9.2.</span> <span class="toc-text">Mixed-Type Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-Operations"><span class="toc-number">9.3.</span> <span class="toc-text">Integer Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function-Parameter-and-Return-Type-Conversion"><span class="toc-number">9.4.</span> <span class="toc-text">Function Parameter and Return Type Conversion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Explicit-Type-Casting"><span class="toc-number">10.</span> <span class="toc-text">Explicit Type Casting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Portable-Data-Types"><span class="toc-number">11.</span> <span class="toc-text">Portable Data Types</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/java-convert-localdatetime-to-long-timestamp/" title="How to Convert LocalDateTime to Long Timestamp in Java">How to Convert LocalDateTime to Long Timestamp in Java</a><time datetime="2024-11-18T17:44:58.000Z" title="Created 2024-11-19 01:44:58">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/15/redis-bitmaps-intro/" title="Introduction to Redis Bitmaps">Introduction to Redis Bitmaps</a><time datetime="2024-11-14T19:43:48.000Z" title="Created 2024-11-15 03:43:48">2024-11-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/10/how-to-install-node-js-latest-long-term-support-version-on-ubuntu-22-04/" title="How to Install Node JS Latest Long-Term Support Version on Ubuntu 22.04?">How to Install Node JS Latest Long-Term Support Version on Ubuntu 22.04?</a><time datetime="2024-11-09T16:59:45.000Z" title="Created 2024-11-10 00:59:45">2024-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/redis-hyperloglog-pfselftest-command/" title="Redis HyperLogLog PFSELFTEST Command">Redis HyperLogLog PFSELFTEST Command</a><time datetime="2024-11-08T16:21:37.000Z" title="Created 2024-11-09 00:21:37">2024-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/redis-hyperloglog-pfdebug-command/" title="Redis HyperLogLog PFDEBUG Command">Redis HyperLogLog PFDEBUG Command</a><time datetime="2024-11-08T16:15:19.000Z" title="Created 2024-11-09 00:15:19">2024-11-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Johnson Lin</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/main.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>