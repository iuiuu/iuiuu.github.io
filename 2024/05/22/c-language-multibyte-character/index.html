<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Multibyte Character in C Language | Johnson Lin</title><meta name="author" content="Johnson Lin"><meta name="copyright" content="Johnson Lin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="keywords" content="Java,JVM,Spring,Spring Boot,Flink,Hadoop,Yarn,MySQL,Elasticsearch,Python,Kafka,Maven,Hbase,Kibana,Logstash,Tutorial,Technical Blogs,Data Structures,Algorithms,C,SQL,Data Science,Web Development,System Design,Interview Experience,Interview Preparation,Programming,Competitive Programming,Coding Contests,HTML,CSS,Computer Science,Programming Examples,Mathematics"><meta name="description" content="Overview of UnicodeWhen the C language was first developed, it primarily focused on English characters, utilizing 7-bit ASCII to represent all characters. The ASCII range spans from 0 to 127, which me">
<meta property="og:type" content="article">
<meta property="og:title" content="Multibyte Character in C Language">
<meta property="og:url" content="http://linjiangxiong.com/2024/05/22/c-language-multibyte-character/index.html">
<meta property="og:site_name" content="Johnson Lin">
<meta property="og:description" content="Overview of UnicodeWhen the C language was first developed, it primarily focused on English characters, utilizing 7-bit ASCII to represent all characters. The ASCII range spans from 0 to 127, which me">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://linjiangxiong.com/image/IMG_3665.JPG">
<meta property="article:published_time" content="2024-05-21T22:15:27.000Z">
<meta property="article:modified_time" content="2024-11-03T14:01:03.168Z">
<meta property="article:author" content="Johnson Lin">
<meta property="article:tag" content="C Programming Language">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://linjiangxiong.com/image/IMG_3665.JPG"><link rel="shortcut icon" href="/image/IMG_3665.JPG"><link rel="canonical" href="http://linjiangxiong.com/2024/05/22/c-language-multibyte-character/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&amp;family=Source+Sans+3:wght@400;600&amp;display=swap"><link rel="stylesheet" href="/css/ud_v5.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ca45da0012a3ce293c6ca4f7e5ebc3a8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Multibyte Character in C Language',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-03 22:01:03'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/IMG_3665.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">304</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Johnson Lin</span></a><a class="nav-page-title" href="/"><span class="site-name">Multibyte Character in C Language</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Multibyte Character in C Language</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-05-21T22:15:27.000Z" title="Created 2024-05-22 06:15:27">2024-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-03T14:01:03.168Z" title="Updated 2024-11-03 22:01:03">2024-11-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Tutorial/">C Tutorial</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="Overview-of-Unicode"><a href="#Overview-of-Unicode" class="headerlink" title="Overview of Unicode"></a>Overview of Unicode</h2><p>When the C language was first developed, it primarily focused on English characters, utilizing 7-bit ASCII to represent all characters. The ASCII range spans from 0 to 127, which means it can represent a maximum of about 128 characters, with each character fitting into a single byte.</p>
<p>However, dealing with non-English characters requires more than one byte. For example, just the Chinese language includes tens of thousands of characters, necessitating a character set that uses multiple bytes.</p>
<p>Initially, different countries had their own character encoding systems, making it difficult to mix various character sets. To address this, Unicode was developed, consolidating all characters into a single character set.</p>
<p>Unicode assigns a unique number to each character, known as a code point. The range from 0 to 127 overlaps with ASCII. Characters are typically represented in the format “U+hexadecimal code point,” where, for example, <code>U+0041</code> represents the letter <code>A</code>.</p>
<p>Currently, Unicode encompasses over a million characters, with code points ranging from U+0000 to U+10FFFF. To fully represent the entire Unicode character set, at least three bytes are needed. However, not all documents require that many characters. For English texts that only use ASCII, representing each character with three bytes would result in files three times larger than necessary.</p>
<p>To accommodate different usage needs, the Unicode Consortium has provided three encoding methods for representing Unicode code points:</p>
<ul>
<li><strong>UTF-8</strong>: Uses 1 to 4 bytes to represent a code point, with the number of bytes varying by character.</li>
<li><strong>UTF-16</strong>: Represents characters in the Basic Multilingual Plane (U+0000 to U+FFFF) with 2 bytes, while other characters use 4 bytes.</li>
<li><strong>UTF-32</strong>: Uses a uniform 4 bytes for each code point.</li>
</ul>
<p>UTF-8 is the most widely used encoding, as it represents ASCII characters (U+0000 to U+007F) with just one byte, making it compatible with traditional ASCII encoding.</p>
<p>C provides two macros that indicate the maximum number of bytes supported for character encoding, both defined in the <code>limits.h</code> header:</p>
<ul>
<li><strong>MB_LEN_MAX</strong>: The maximum byte length supported by any locale.</li>
<li><strong>MB_CUR_MAX</strong>: The maximum byte length for the current locale, which is always less than or equal to MB_LEN_MAX.</li>
</ul>
<h2 id="Character-Representation"><a href="#Character-Representation" class="headerlink" title="Character Representation"></a>Character Representation</h2><p>The essence of character representation is mapping each character to an integer, allowing retrieval from an encoding table.</p>
<p>C offers various methods to express the integer values of characters:</p>
<ul>
<li><code>\123</code>: Represents a character using an octal value (three digits following the backslash).</li>
<li><code>\x4D</code>: Represents a character using a hexadecimal value (<code>\x</code> followed by a hexadecimal integer).</li>
<li><code>\u2620</code>: Represents a character using a Unicode code point (not applicable to ASCII), with four hexadecimal digits following <code>\u</code>.</li>
<li><code>\U0001243F</code>: Represents a character using a Unicode code point (not applicable to ASCII), with eight hexadecimal digits following <code>\U</code>.</li>
</ul>
<p>Examples:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ABC\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\101\102\103\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\x41\x42\x43\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>All three lines output “ABC”.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\u2022 Bullet 1\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\U00002022 Bullet 1\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Both of these lines output “• Bullet 1”.</p>
<h2 id="Representation-of-Multi-Byte-Characters-in-C"><a href="#Representation-of-Multi-Byte-Characters-in-C" class="headerlink" title="Representation of Multi-Byte Characters in C"></a>Representation of Multi-Byte Characters in C</h2><p>In C, only basic characters can be represented using string literals. Other characters should be represented using their code points, and the current system must support the encoding method for those code points.</p>
<p><strong>Basic characters</strong> refer to all printable ASCII characters, with three exceptions: <code>@</code>, <code>$</code>, and ```.</p>
<p>Thus, for non-English characters, you should use the Unicode code point format.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;\u6625\u5929&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); <span class="comment">// Outputs: 春天</span></span><br></pre></td></tr></table></figure>



<p>The code above outputs the Chinese word “春天” (spring).</p>
<p>If the current system uses UTF-8 encoding, you can directly represent multi-byte characters with string literals:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>



<p>Note that the <code>\u</code> and <code>\U</code> syntax cannot be used to represent ASCII characters (code points less than <code>0xA0</code>), except for the following three characters: <code>0x24</code> (<code>$</code>), <code>0x40</code> (<code>@</code>), and <code>0x60</code> (```).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;\u0024\u0040\u0060&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);  <span class="comment">// Outputs: @$`</span></span><br></pre></td></tr></table></figure>



<p>The code above correctly outputs the three Unicode characters “@$`”, but other ASCII characters cannot be represented this way.</p>
<p>To ensure that characters are correctly interpreted during program execution, it’s best to switch the program environment to a localized setting:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>The <code>setlocale()</code> function changes the execution environment to the system’s locale language. Its prototype is defined in the header file <code>locale.h</code>, as detailed in the standard library section on <code>locale.h</code>.</p>
<p>You can also specify the encoding explicitly:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;zh_CN.UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>This switches the program environment to a Chinese locale with UTF-8 encoding.</p>
<p>C also allows the use of the <code>u8</code> prefix to specify UTF-8 encoding for multi-byte strings:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">u8&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>



<p>When a string contains multi-byte characters, the number of bytes does not equal the number of characters. For example, a string may be 10 bytes long but contain only 7 or 5 characters.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(s)); <span class="comment">// Outputs: 6</span></span><br></pre></td></tr></table></figure>



<p>In this example, the string <code>s</code> contains only two characters, but <code>strlen()</code> returns 6, indicating that these two characters occupy 6 bytes.</p>
<p>C’s string functions only work with single-byte characters, so functions like <code>strtok()</code>, <code>strchr()</code>, <code>strspn()</code>, <code>toupper()</code>, <code>tolower()</code>, and <code>isalpha()</code> will not yield correct results with multi-byte characters.</p>
<h2 id="Wide-Characters"><a href="#Wide-Characters" class="headerlink" title="Wide Characters"></a>Wide Characters</h2><p>In the previous section, we discussed multi-byte strings, where the byte width of each character can vary. While this encoding method is convenient, it complicates string processing since each character must be examined individually to determine its byte length. To address this, C provides a fixed-width character storage method known as <strong>wide characters</strong>.</p>
<p><strong>Wide characters</strong> use a consistent number of bytes per character, either 2 bytes or 4 bytes. This uniformity simplifies and speeds up processing.</p>
<p>Wide characters are represented by a specific data type, <code>wchar_t</code>, which can be either signed or unsigned, depending on the implementation. This type typically has a length of 16 bits (2 bytes) or 32 bits (4 bytes), making it capable of storing all characters used by the current system. The <code>wchar_t</code> type is defined in the header file <code>wchar.h</code>.</p>
<p>To define wide character literals, you must prefix them with an “L”. Without this prefix, C will treat the literal as a narrow character type.</p>
<p>Here’s an example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> c = <span class="string">L&#x27;牛&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lc\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span>* s = <span class="string">L&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>In this example, the “L” prefix before the single quote indicates a wide character, which corresponds to the <code>%lc</code> format specifier in <code>printf()</code>. Similarly, the prefix before the double quote signifies a wide string, corresponding to the <code>%ls</code> specifier.</p>
<p>Wide strings also end with a wide null character, which occupies multiple bytes.</p>
<p>When working with wide characters, you should use functions specifically designed for them, most of which are defined in the <code>wchar.h</code> header file.</p>
<h2 id="Multibyte-Character-Handling-Functions"><a href="#Multibyte-Character-Handling-Functions" class="headerlink" title="Multibyte Character Handling Functions"></a>Multibyte Character Handling Functions</h2><h3 id="mblen"><a href="#mblen" class="headerlink" title="mblen()"></a><strong>mblen()</strong></h3><p>The <code>mblen()</code> function returns the number of bytes occupied by a multibyte character. Its prototype is defined in the <code>stdlib.h</code> header file:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mblen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* mbstr, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>



<p>This function takes two parameters: the first is a pointer to a multibyte string, which typically checks the first character of the string; the second is the number of bytes to check, which should not exceed the maximum bytes used by a single character on the current system, typically represented by <code>MB_CUR_MAX</code>.</p>
<p>The return value indicates the number of bytes used by the current character. If the character is a null wide character, it returns 0; if the character is invalid, it returns -1.</p>
<p>Example usage:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs1 = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mblen(mbs1, MB_CUR_MAX)); <span class="comment">// Outputs: 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mblen(mbs2, MB_CUR_MAX)); <span class="comment">// Outputs: 1</span></span><br></pre></td></tr></table></figure>



<p>In the examples above, the first character “春” in the string “春天” occupies 3 bytes, while the first character “a” in the string “abc” occupies 1 byte.</p>
<h3 id="wctomb"><a href="#wctomb" class="headerlink" title="wctomb()"></a>wctomb()</h3><p>The <code>wctomb()</code> function (wide character to multibyte) converts a wide character to a multibyte character. Its prototype is also defined in the <code>stdlib.h</code> header file:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wctomb</span><span class="params">(<span class="type">char</span>* s, <span class="type">wchar_t</span> wc)</span>;</span><br></pre></td></tr></table></figure>

<p><code>wctomb()</code> takes two parameters: the first is a buffer for the resulting multibyte character, and the second is the wide character to convert. The return value indicates the number of bytes used to store the multibyte character; if the conversion fails, it returns -1.</p>
<p>Example usage:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> wc = <span class="string">L&#x27;牛&#x27;</span>;</span><br><span class="line"><span class="type">char</span> mbStr[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = wctomb(mbStr, wc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mbStr);  <span class="comment">// Outputs: 牛</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes);  <span class="comment">// Outputs: 3</span></span><br></pre></td></tr></table></figure>

<p>In this example, <code>wctomb()</code> converts the wide character “牛” into a multibyte character, and the return value indicates that it occupies 3 bytes.</p>
<h3 id="mbtowc"><a href="#mbtowc" class="headerlink" title="mbtowc()"></a>mbtowc()</h3><p>The <code>mbtowc()</code> function converts a multibyte character to a wide character. Its prototype is defined in the header file <code>stdlib.h</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mbtowc</span><span class="params">(<span class="type">wchar_t</span>* wchar, <span class="type">const</span> <span class="type">char</span>* mbchar, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Parameters:</strong></p>
<ul>
<li><code>wchar_t* wchar</code>: A pointer to the wide character that will store the result.</li>
<li><code>const char* mbchar</code>: A pointer to the multibyte character to be converted.</li>
<li><code>size_t count</code>: The number of bytes available in the multibyte character.</li>
</ul>
<p><strong>Return Value:</strong><br>Returns the number of bytes used by the multibyte character if successful; returns -1 if the conversion fails.</p>
<p><strong>Example:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbchar = <span class="string">&quot;牛&quot;</span>;</span><br><span class="line"><span class="type">wchar_t</span> wc;</span><br><span class="line"><span class="type">wchar_t</span>* pwc = &amp;wc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = mbtowc(pwc, mbchar, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// Output: 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lc\n&quot;</span>, *pwc);  <span class="comment">// Output: 牛</span></span><br></pre></td></tr></table></figure>

<p>In this example, <code>mbtowc()</code> converts the multibyte character “牛” to the wide character <code>wc</code>, returning 3 as the number of bytes used by <code>mbchar</code>.</p>
<h3 id="wcstombs"><a href="#wcstombs" class="headerlink" title="wcstombs()"></a>wcstombs()</h3><p>The <code>wcstombs()</code> function converts a wide string to a multibyte string. Its prototype is also defined in <code>stdlib.h</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">wcstombs</span><span class="params">(<span class="type">char</span>* mbstr, <span class="type">const</span> <span class="type">wchar_t</span>* wcstr, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Parameters:</strong></p>
<ul>
<li><code>char* mbstr</code>: A pointer to the destination multibyte string.</li>
<li><code>const wchar_t* wcstr</code>: A pointer to the wide string to be converted.</li>
<li><code>size_t count</code>: The maximum number of bytes to write to the multibyte string.</li>
</ul>
<p><strong>Return Value:</strong><br>Returns the number of bytes written to the multibyte string, not including the terminating null byte; returns -1 if the conversion fails.</p>
<p><strong>Example:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> mbs[<span class="number">20</span>];</span><br><span class="line"><span class="type">wchar_t</span>* wcs = <span class="string">L&quot;春天&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = wcstombs(mbs, wcs, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mbs); <span class="comment">// Output: 春天</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// Output: 6</span></span><br></pre></td></tr></table></figure>

<p>In this case, <code>wcstombs()</code> converts the wide string <code>wcs</code> to the multibyte string <code>mbs</code>, returning 6, which represents the number of bytes written, excluding the null terminator.</p>
<p>If the first argument of <code>wcstombs()</code> is NULL, the function returns the number of bytes required for the conversion.</p>
<h3 id="mbstowcs"><a href="#mbstowcs" class="headerlink" title="mbstowcs()"></a>mbstowcs()</h3><p>The <code>mbstowcs()</code> function converts a multibyte string to a wide string. Its prototype is defined in <code>stdlib.h</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">mbstowcs</span><span class="params">(<span class="type">wchar_t</span>* wcstr, <span class="type">const</span> <span class="type">char</span>* mbstr, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Parameters:</strong></p>
<ul>
<li><code>wchar_t* wcstr</code>: A pointer to the destination wide string.</li>
<li><code>const char* mbstr</code>: A pointer to the multibyte string to be converted.</li>
<li><code>size_t count</code>: The maximum number of multibyte characters to convert.</li>
</ul>
<p><strong>Return Value:</strong><br>Returns the number of wide characters successfully converted; returns -1 if the conversion fails. If the return value equals the third parameter, the resulting wide string is not null-terminated.</p>
<p><strong>Example:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs = <span class="string">&quot;天气不错&quot;</span>;</span><br><span class="line"><span class="type">wchar_t</span> wcs[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = mbstowcs(wcs, mbs, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, wcs); <span class="comment">// Output: 天气不错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// Output: 4</span></span><br></pre></td></tr></table></figure>

<p>In this example, the multibyte string <code>mbs</code> is converted to a wide string <code>wcs</code>, successfully converting 4 characters, which is reflected in the return value.</p>
<p>If the first argument of <code>mbstowcs()</code> is NULL, the function returns the number of wide characters that would be generated.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com">Johnson Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com/2024/05/22/c-language-multibyte-character/">http://linjiangxiong.com/2024/05/22/c-language-multibyte-character/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Programming-Language/">C Programming Language</a></div><div class="post-share"><div class="social-share" data-image="/image/IMG_3665.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/05/23/c-language-lib-assert-h/" title="assert.h in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">assert.h in C Language</div></div><div class="info-2"><div class="info-item-1">assert()The assert.h header file defines the assert() macro, which is used to verify that a program meets certain conditions at runtime. If a condition is not met, the program will terminate with an error message. This macro is often referred to as an “assertion.” For example, consider the following code: 1assert(PI &gt; 3);    When the program reaches this line, it checks whether the variable PI is greater than 3. If it is, the program continues to run; if not, the program will terminate...</div></div></div></a><a class="pagination-related" href="/2024/05/21/c-language-cli/" title="CLI in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">CLI in C Language</div></div><div class="info-2"><div class="info-item-1">Command Line ArgumentsC programs can receive parameters from the command line. For example, running: 1$ ./foo hello world  The program foo receives two command line arguments: hello and world. How does the program access these command line arguments? C stores the command line input in an array, which can be accessed through the parameters of the main() function. 1234567#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123;    for (int i = 0; i &lt; argc; i++) &#123;       ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/05/05/c-language-flow-control/" title="Flow Control in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-05</div><div class="info-item-2">Flow Control in C Language</div></div><div class="info-2"><div class="info-item-1">In C programming, execution is sequential, meaning statements are executed one after the other. To control the flow of execution, developers use flow control structures, primarily conditional and loop statements. if StatementThe if statement is used for conditional execution; it executes a specified statement if the condition is true. Syntax: 1if (expression) statement  Here, expression must be true (non-zero) for statement to execute. The condition inside the parentheses must be enclosed in...</div></div></div></a><a class="pagination-related" href="/2024/05/07/c-language-pointer/" title="Pointer in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-07</div><div class="info-item-2">Pointer in C Language</div></div><div class="info-2"><div class="info-item-1">Pointers are one of the most important and challenging concepts in the C programming language. OverviewWhat is a pointer? In essence, it’s a value representing a memory address, acting as a signpost to a specific location in memory. The asterisk * represents a pointer and is usually placed after the type keyword to indicate what type of value the pointer is referencing. For example, char* is a pointer to a character, and float* is a pointer to a float. 1int* intPtr;  The above example...</div></div></div></a><a class="pagination-related" href="/2024/05/01/introduction-to-the-c-language/" title="Introduction to the C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-01</div><div class="info-item-2">Introduction to the C Language</div></div><div class="info-2"><div class="info-item-1">HistoryThe C programming language was originally invented as a tool for developing the Unix operating system. In 1969, Ken Thompson and Dennis Ritchie at Bell Labs in the United States developed the Unix operating system. Unix was initially written in assembly language, making it difficult to port to other computers. To address this, they decided to rewrite it in a high-level language. However, existing high-level languages at the time did not meet their needs, so Thompson developed the B...</div></div></div></a><a class="pagination-related" href="/2024/05/02/basic-c-language-syntax/" title="Basic C Language Syntax"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-02</div><div class="info-item-2">Basic C Language Syntax</div></div><div class="info-2"><div class="info-item-1">StatementsC code is composed of statements. A statement is a command that the program executes. In C, each statement must end with a semicolon, unless specified otherwise. 1int x = 1;  The above is a variable declaration statement, where the integer variable x is declared and assigned a value of 1. Multiple statements can be written on a single line: 1int x; x = 1;  Here, two statements are written on one line. Line breaks between statements aren’t required but are often used for...</div></div></div></a><a class="pagination-related" href="/2024/05/08/c-language-function/" title="Functions in C Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-08</div><div class="info-item-2">Functions in C Language</div></div><div class="info-2"><div class="info-item-1">OverviewA function is a reusable block of code that can accept different parameters and perform specific tasks. Here’s an example of a function: 123int plus_one(int n) &#123;  return n + 1;&#125;  This code declares a function named plus_one(). Key Points of Function Declarations:  Return Type: Specify the return type at the start of the declaration. In the example, int indicates the function returns an integer. Parameters: Declare the types and names of parameters in parentheses following...</div></div></div></a><a class="pagination-related" href="/2024/05/03/c-language-variables/" title="Understanding Variables in C Programming"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="info-item-2">Understanding Variables in C Programming</div></div><div class="info-2"><div class="info-item-1">A variable can be understood as the name of a memory location. By using the variable name, you can reference this memory and access the stored value. The value might change, which is why it’s called a variable. If the value remains constant, it’s referred to as a constant. Variable NamesIn C, variable names are considered identifiers, and there are strict rules for naming them:  They can only contain letters (both uppercase and lowercase), digits, and underscores (_). They cannot begin with...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/IMG_3665.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Johnson Lin</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">304</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iuiuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/iuiuu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:me@linjiangxiong.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview-of-Unicode"><span class="toc-number">1.</span> <span class="toc-text">Overview of Unicode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Character-Representation"><span class="toc-number">2.</span> <span class="toc-text">Character Representation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Representation-of-Multi-Byte-Characters-in-C"><span class="toc-number">3.</span> <span class="toc-text">Representation of Multi-Byte Characters in C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wide-Characters"><span class="toc-number">4.</span> <span class="toc-text">Wide Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multibyte-Character-Handling-Functions"><span class="toc-number">5.</span> <span class="toc-text">Multibyte Character Handling Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mblen"><span class="toc-number">5.1.</span> <span class="toc-text">mblen()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wctomb"><span class="toc-number">5.2.</span> <span class="toc-text">wctomb()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mbtowc"><span class="toc-number">5.3.</span> <span class="toc-text">mbtowc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wcstombs"><span class="toc-number">5.4.</span> <span class="toc-text">wcstombs()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mbstowcs"><span class="toc-number">5.5.</span> <span class="toc-text">mbstowcs()</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/18/bulk-deleting-keys-in-redis-using-wildcards/" title="Bulk Deleting Keys in Redis Using Wildcards">Bulk Deleting Keys in Redis Using Wildcards</a><time datetime="2024-09-18T15:42:56.000Z" title="Created 2024-09-18 23:42:56">2024-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/11/analyzing-redis-source-code-hash/" title="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing"><img src="/image/redis-src/2024091101.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing"/></a><div class="content"><a class="title" href="/2024/09/11/analyzing-redis-source-code-hash/" title="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing">Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing</a><time datetime="2024-09-10T22:28:03.000Z" title="Created 2024-09-11 06:28:03">2024-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/10/analyzing-redis-source-code-sds/" title="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation"><img src="/image/redis-src/24091002.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation"/></a><div class="content"><a class="title" href="/2024/09/10/analyzing-redis-source-code-sds/" title="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation">Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation</a><time datetime="2024-09-09T17:13:55.000Z" title="Created 2024-09-10 01:13:55">2024-09-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/06/why-does-redis-use-the-sds-structure-for-strings-instead-of-char/" title="Why Does Redis Use the SDS Structure for Strings Instead of char*?">Why Does Redis Use the SDS Structure for Strings Instead of char*?</a><time datetime="2024-09-05T16:01:26.000Z" title="Created 2024-09-06 00:01:26">2024-09-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/05/how-to-delete-data-in-elasticsearch-single-multiple-clear-and-all/" title="How to Delete Data in Elasticsearch: Single, Multiple, Clear, and All">How to Delete Data in Elasticsearch: Single, Multiple, Clear, and All</a><time datetime="2024-09-04T16:02:38.000Z" title="Created 2024-09-05 00:02:38">2024-09-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Johnson Lin</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/main.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>