<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation | Johnson Lin</title><meta name="author" content="Johnson Lin"><meta name="copyright" content="Johnson Lin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis’s Requirements for StringsStrings are an essential data type in app development, frequently used to store a variety of information such as user profiles, product descriptions, and system message">
<meta property="og:type" content="article">
<meta property="og:title" content="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation">
<meta property="og:url" content="http://linjiangxiong.com/2024/09/10/analyzing-redis-source-code-sds/index.html">
<meta property="og:site_name" content="Johnson Lin">
<meta property="og:description" content="Redis’s Requirements for StringsStrings are an essential data type in app development, frequently used to store a variety of information such as user profiles, product descriptions, and system message">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://linjiangxiong.com/image/redis-src/24091002.png">
<meta property="article:published_time" content="2024-09-09T17:13:55.000Z">
<meta property="article:modified_time" content="2024-12-03T21:57:29.000Z">
<meta property="article:author" content="Johnson Lin">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://linjiangxiong.com/image/redis-src/24091002.png"><link rel="shortcut icon" href="/image/IMG_3665.JPG"><link rel="canonical" href="http://linjiangxiong.com/2024/09/10/analyzing-redis-source-code-sds/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&amp;family=Source+Sans+3:wght@400;600&amp;display=swap"><link rel="stylesheet" href="/css/ud_v5.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ca45da0012a3ce293c6ca4f7e5ebc3a8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/IMG_3665.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">476</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/2024/08/27/yaml-tutorial/"><i class="fa-fw fas fa-book"></i><span> YAML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><span> Dev Wiki</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/11/29/wiki/standard-ascii-table/"><i class="fa-fw fas fa-book"></i><span> Standard ASCII Table (7-bit)</span></a></li><li><a class="site-page child" href="/2024/11/30/wiki/html-char/"><i class="fa-fw fas fa-book"></i><span> Html Special Char</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Johnson Lin</span></a><a class="nav-page-title" href="/"><span class="site-name">Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/2024/08/27/yaml-tutorial/"><i class="fa-fw fas fa-book"></i><span> YAML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><span> Dev Wiki</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/11/29/wiki/standard-ascii-table/"><i class="fa-fw fas fa-book"></i><span> Standard ASCII Table (7-bit)</span></a></li><li><a class="site-page child" href="/2024/11/30/wiki/html-char/"><i class="fa-fw fas fa-book"></i><span> Html Special Char</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-09T17:13:55.000Z" title="Created 2024-09-10 01:13:55">2024-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-12-03T21:57:29.000Z" title="Updated 2024-12-04 05:57:29">2024-12-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis-Source-Code-Analysis/">Redis Source Code Analysis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="Redis’s-Requirements-for-Strings"><a href="#Redis’s-Requirements-for-Strings" class="headerlink" title="Redis’s Requirements for Strings"></a>Redis’s Requirements for Strings</h2><p>Strings are an essential data type in app development, frequently used to store a variety of information such as user profiles, product descriptions, and system messages. In Redis, a popular in-memory data store, both the keys and often the values in key-value pairs are represented as strings. This makes strings one of the foundational data types in Redis, contributing to its flexibility and simplicity when handling data. </p>
<p>For instance, when saving user data such as name, gender, and city, you can use a simple Redis command like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET user:id:100 &#123;&quot;name&quot;: &quot;John&quot;, &quot;gender&quot;: &quot;M&quot;, &quot;city&quot;: &quot;New York&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>This example stores a stringified JSON object as the value, with a key that identifies the user.</p>
<p>Strings are also crucial for communication in Redis. The commands exchanged between Redis instances and clients, as well as much of the internal data, are transmitted as strings. Given the widespread use of strings in Redis, the way strings are implemented plays a critical role in system performance and efficiency. To optimize this, the implementation should satisfy the following three key requirements:</p>
<h3 id="1-Support-for-a-Wide-Range-of-Efficient-String-Operations"><a href="#1-Support-for-a-Wide-Range-of-Efficient-String-Operations" class="headerlink" title="1. Support for a Wide Range of Efficient String Operations"></a>1. <strong>Support for a Wide Range of Efficient String Operations</strong></h3><p>String operations like appending, copying, comparing, and retrieving the length of a string are extremely common in app development. In Redis, strings are implemented in such a way that these operations are highly efficient. For example, appending data to a string can be done using the <code>APPEND</code> command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND user:name &quot;Doe&quot;</span><br></pre></td></tr></table></figure>
<p>This adds “Doe” to the existing string value stored at the <code>user:name</code> key. Similar commands exist for other operations like comparing (<code>STRLEN</code>) or copying strings. Efficient handling of these operations ensures that Redis remains performant, even as the volume of data grows.</p>
<h3 id="2-Ability-to-Handle-Arbitrary-Binary-Data"><a href="#2-Ability-to-Handle-Arbitrary-Binary-Data" class="headerlink" title="2. Ability to Handle Arbitrary Binary Data"></a>2. <strong>Ability to Handle Arbitrary Binary Data</strong></h3><p>Strings in Redis are not limited to human-readable text. They can also store binary data such as images, audio files, or other types of raw data. This flexibility is crucial in modern app development, where applications frequently need to handle multimedia or complex data formats. Redis strings can store up to 512MB of binary data, allowing developers to use them for a variety of tasks beyond simple text storage.</p>
<p>For example, storing an image file in Redis might involve converting the image to binary and saving it as a string:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET image:profile:100 &lt;binary_data&gt;</span><br></pre></td></tr></table></figure>
<p>Redis doesn’t distinguish between text and binary data at the storage level, so it treats everything as a string, making the system both simple and flexible.</p>
<h3 id="3-Minimizing-Memory-Overhead"><a href="#3-Minimizing-Memory-Overhead" class="headerlink" title="3. Minimizing Memory Overhead"></a>3. <strong>Minimizing Memory Overhead</strong></h3><p>Since Redis is often used in scenarios where speed and memory efficiency are critical, minimizing memory overhead for string storage is essential. Redis uses an optimized memory representation for strings. Short strings (typically 39 bytes or less) are stored in a highly efficient structure known as <strong>SDS</strong> (Simple Dynamic Strings), which reduces the overhead associated with managing string data.</p>
<p>Redis takes several measures to optimize memory usage:</p>
<ul>
<li><strong>SDS Structure:</strong> SDS supports dynamic resizing, allowing it to efficiently manage memory when strings are appended or modified without needing to frequently reallocate memory.</li>
<li><strong>Lazy Reallocation:</strong> Redis avoids unnecessary memory allocation by resizing strings in chunks, reducing the cost of frequent modifications.</li>
<li><strong>Compact Storage for Small Strings:</strong> Small strings are packed together, reducing fragmentation and overall memory consumption.</li>
</ul>
<h2 id="Why-doesn’t-Redis-Use-char"><a href="#Why-doesn’t-Redis-Use-char" class="headerlink" title="Why doesn’t Redis Use char*?"></a>Why doesn’t Redis Use <code>char*</code>?</h2><p>If you’ve developed programs in C, you’re probably familiar with using <code>char*</code> arrays to implement strings. The C standard library (<code>string.h</code>) provides various string operations like <code>strcmp</code> for comparison, <code>strlen</code> for length, and <code>strcat</code> for appending, which simplifies these tasks for developers. However, why doesn’t Redis use <code>char*</code>? To answer this question, we first need to understand the structure of <code>char*</code> string arrays. Let’s delve into that analysis.</p>
<h3 id="The-Design-of-char-Struct"><a href="#The-Design-of-char-Struct" class="headerlink" title="The Design of char* Struct"></a>The Design of <code>char*</code> Struct</h3><p>The <code>char*</code> array is a simple structure consisting of a contiguous block of memory where each character of the string is stored sequentially. For example, the <code>char*</code> array structure for the string “johnson” is shown below. </p>
<p><img src="/image/redis-src/24091001.png" alt=""></p>
<p>The last character in this array is <code>&#39;\0&#39;</code>. This character is crucial because it marks the end of the string. In C, <code>char*</code> pointers refer to the start of the array, and functions in the standard library use <code>&#39;\0&#39;</code> to determine where the string ends. For instance, the <code>strlen</code> function calculates the length of a string by counting characters until it encounters <code>&#39;\0&#39;</code>. The execution flow of <code>strlen</code> is illustrated below.</p>
<p><img src="/image/redis-src/24091002.png" alt=""></p>
<p>Let’s look at how the <code>&#39;\0&#39;</code> termination character affects string length with a code example. I’ve created two string variables, <code>a</code> and <code>b</code>, with values <code>&quot;john\0son&quot;</code> and <code>&quot;johnson\0&quot;</code>, respectively. Using the <code>strlen</code> function to compute their lengths, the results are 4 and 7. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = <span class="string">&quot;john\0son&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *b = <span class="string">&quot;johnson\0&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="built_in">strlen</span>(b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is because the <code>&#39;\0&#39;</code> in <code>a</code> comes after “john”, so <code>strlen</code> counts only the first 4 characters. For <code>b</code>, the <code>&#39;\0&#39;</code> is after “johnson”, so <code>strlen</code> counts all 7 characters. This shows that <code>char*</code> strings, which use <code>&#39;\0&#39;</code> to indicate the end, can be problematic if the data itself contains <code>&#39;\0&#39;</code>, as it leads to truncation. This limitation makes it unsuitable for storing arbitrary binary data, which is what Redis needs to handle.</p>
<h3 id="The-Complexity-of-String-Operations"><a href="#The-Complexity-of-String-Operations" class="headerlink" title="The Complexity of String Operations"></a>The Complexity of String Operations</h3><p>Aside from design issues related to <code>char*</code> character arrays, using <code>&#39;\0&#39;</code> as the string terminator allows functions to determine where the string ends. However, it also has a downside: it increases the complexity of string operations. Take the <code>strlen</code> function as an example. This function needs to traverse each character in the array to determine the string’s length, resulting in a time complexity of O(N).</p>
<p>Another commonly used operation is the string concatenation function, <code>strcat</code>. The <code>strcat</code> function appends a source string (<code>src</code>) to the end of a destination string. Here’s how the <code>strcat</code> function works:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strcat - Concatenates two strings</span></span><br><span class="line"><span class="comment"> * @dest: Destination string to which the source string will be appended</span></span><br><span class="line"><span class="comment"> * @src: Source string that will be appended to the destination string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function concatenates the source string `src` to the end of the destination string `dest`.</span></span><br><span class="line"><span class="comment"> * It first finds the end of the destination string `dest` (the first null character),</span></span><br><span class="line"><span class="comment"> * then copies each character from the source string `src` into the destination string `dest`</span></span><br><span class="line"><span class="comment"> * until the null character of the source string `src` is reached. Finally, it returns the original pointer to the destination string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: Pointer to the destination string after concatenation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Temporarily store the pointer to the destination string</span></span><br><span class="line">        <span class="type">char</span> *tmp = dest;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the end of the destination string</span></span><br><span class="line">        <span class="keyword">while</span> (*dest)</span><br><span class="line">                dest++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy each character from the source string to the destination string until the null character</span></span><br><span class="line">        <span class="keyword">while</span> ((*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the original pointer to the destination string</span></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>From the code, we can see that both <code>strcat</code> and <code>strlen</code> functions have high complexity. They both require traversing the strings to find their end. For <code>strcat</code>, there’s an additional traversal needed to append the source string to the destination. Furthermore, <code>strcat</code> must ensure that there is enough space in the destination string to accommodate the new content; otherwise, the append operation will fail.</p>
<p>This means developers need to manage the space for the destination string carefully when using <code>strcat</code>, often requiring dynamic allocation which adds to the programming complexity. Increased complexity in these operations affects the efficiency of string manipulation, which does not align with Redis’s need for efficient string handling.</p>
<p>Considering the shortcomings of using <code>char*</code> for string implementation in C, we now need to explore alternative ways to handle strings. Therefore, next, let’s delve into how Redis approaches the design considerations for string implementation.</p>
<h2 id="Design-Philosophy-of-SDS"><a href="#Design-Philosophy-of-SDS" class="headerlink" title="Design Philosophy of SDS"></a>Design Philosophy of SDS</h2><p>Since Redis is developed in C, it leverages character arrays to store data for compatibility with C standard library functions. However, unlike C’s basic character arrays, Redis introduces a specially designed data structure called SDS (Simple Dynamic Strings). Let’s take a closer look at it.</p>
<h3 id="SDS-Structure-Design"><a href="#SDS-Structure-Design" class="headerlink" title="SDS Structure Design"></a>SDS Structure Design</h3><p>The SDS structure includes a character array <code>buf[]</code> for storing actual data. Additionally, it contains three pieces of metadata: </p>
<ul>
<li><code>len</code> (the length of the data in the array), </li>
<li><code>alloc</code> (the allocated space for the array), </li>
<li>and <code>flags</code> (the type of SDS). </li>
</ul>
<p>Redis defines various data types for <code>len</code> and <code>alloc</code> to represent different SDS types, which I will explain in detail later. The diagram below illustrates the SDS structure for reference.</p>
<p><img src="/image/redis-src/24091003.png" alt=""></p>
<p>If you’ve looked into the Redis source code, you may have noticed that Redis uses <code>typedef</code> to create an alias <code>sds</code> for <code>char*</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br></pre></td></tr></table></figure>
<p>This is because, fundamentally, SDS is a character array with added metadata. In Redis, <code>sds</code> is used whenever character arrays are needed.</p>
<p>When creating a new string, Redis calls the SDS creation function <code>sdsnewlen</code>. This function allocates a new <code>sds</code> variable (essentially a <code>char*</code>), initializes an SDS structure, and assigns the <code>buf[]</code> array in the SDS structure to the <code>sds</code> variable. Finally, <code>sdsnewlen</code> copies the desired string into the <code>sds</code> variable. The code below illustrates the logic of the <code>sdsnewlen</code> function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string with the content specified by the &#x27;init&#x27; pointer</span></span><br><span class="line"><span class="comment"> * and &#x27;initlen&#x27;.</span></span><br><span class="line"><span class="comment"> * If NULL is used for &#x27;init&#x27; the string is initialized with zero bytes.</span></span><br><span class="line"><span class="comment"> * If SDS_NOINIT is used, the buffer is left uninitialized;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class="line"><span class="comment"> * even if you create an sds string with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mystring = sdsnewlen(&quot;abc&quot;,3);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can print the string with printf() as there is an implicit \0 at the</span></span><br><span class="line"><span class="comment"> * end of the string. However the string is binary safe and can contain</span></span><br><span class="line"><span class="comment"> * \0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class="line">sds _sdsnewlen(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen, <span class="type">int</span> trymalloc) &#123;</span><br><span class="line">    <span class="type">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="type">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="type">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    <span class="type">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    assert(initlen + hdrlen + <span class="number">1</span> &gt; initlen); <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line">    sh = trymalloc?</span><br><span class="line">        s_trymalloc_usable(hdrlen+initlen+<span class="number">1</span>, &amp;usable) :</span><br><span class="line">        s_malloc_usable(hdrlen+initlen+<span class="number">1</span>, &amp;usable);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    s = (<span class="type">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="type">unsigned</span> <span class="type">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    usable = usable-hdrlen<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With an understanding of the SDS structure, let’s now explore how SDS improves operation efficiency compared to traditional C strings.</p>
<h3 id="SDS-Operation-Efficiency"><a href="#SDS-Operation-Efficiency" class="headerlink" title="SDS Operation Efficiency"></a>SDS Operation Efficiency</h3><p>The SDS structure tracks both the used and allocated space for the character array, which provides greater efficiency compared to traditional C strings. For example, consider the string append operation. In Redis, the function for appending strings is <code>sdscatlen</code> in the <code>sds.c</code> file. This function takes three parameters: the target string <code>s</code>, the source string <code>t</code>, and the length <code>len</code> to append. Here’s the relevant source code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append the specified binary-safe string pointed by &#x27;t&#x27; of &#x27;len&#x27; bytes to the</span></span><br><span class="line"><span class="comment"> * end of the specified sds string &#x27;s&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line">sds <span class="title function_">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By analyzing the source code of this function, we can see that the implementation of <code>sdscatlen</code> is quite straightforward and consists of three main steps:</p>
<ol>
<li>First, it retrieves the current length of the destination string and calls <code>sdsMakeRoomFor</code> to check if additional space is needed based on the current length and the length of the data to append. This step ensures there is enough space to accommodate the new data.</li>
<li>Once sufficient space is confirmed, the function appends the specified length of data from the source string to the destination string.</li>
<li>Finally, it updates the length of the destination string.</li>
</ol>
<p>I’ve included a diagram illustrating the execution process of <code>sdscatlen</code> for clarity. Compared to string operations in C, SDS avoids the need for traversing the string by keeping track of the used length and allocated space, which reduces operational overhead. This design approach makes operations like creation, appending, copying, and comparison more efficient and is worth emulating.</p>
<p><img src="/image/redis-src/24091004.png" alt=""></p>
<p>Additionally, SDS encapsulates space checking and resizing for the target string in the <code>sdsMakeRoomFor</code> function. This function is called directly for operations that involve changing the string’s space, such as appending or copying. </p>
<p>This design prevents developers from forgetting to resize the target string, which could otherwise lead to failed operations. For instance, when using the <code>strcpy(char *dest, const char *src)</code> function, if <code>src</code> is longer than <code>dest</code> and we don’t check for this, it could result in a buffer overflow. Thus, this encapsulation approach is a valuable design principle to adopt.</p>
<p>Now, besides using metadata to track string length and the encapsulation approach, what other excellent design and implementation aspects does SDS offer? This is related to the memory efficiency needs I mentioned earlier about Redis.</p>
<p>Let’s delve into how SDS employs programming techniques to optimize memory usage.</p>
<h3 id="Programming-Techniques-for-Compact-String-Structures"><a href="#Programming-Techniques-for-Compact-String-Structures" class="headerlink" title="Programming Techniques for Compact String Structures"></a>Programming Techniques for Compact String Structures</h3><p>Earlier, I mentioned that the SDS structure includes a metadata field called <code>flags</code>, which indicates the SDS type. In fact, SDS defines five types: <code>sdshdr5</code>, <code>sdshdr8</code>, <code>sdshdr16</code>, <code>sdshdr32</code>, and <code>sdshdr64</code>. The key difference among these types lies in the data types used for the <code>len</code> (current length) and <code>alloc</code> (allocated space) fields in their data structures.</p>
<p>Since Redis no longer uses the <code>sdshdr5</code> type, we’ll focus on the remaining four types. For example, here’s the definition of <code>sdshdr8</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We can see that for <code>sdshdr8</code>, both the current length (<code>len</code>) and allocated space (<code>alloc</code>) use <code>uint8_t</code>, an 8-bit unsigned integer that occupies 1 byte. This means that with <code>sdshdr8</code>, the maximum length of the character array, including the null terminator, is 256 bytes (2^8). </p>
<p>For <code>sdshdr16</code>, <code>sdshdr32</code>, and <code>sdshdr64</code>, the <code>len</code> and <code>alloc</code> fields are <code>uint16_t</code>, <code>uint32_t</code>, and <code>uint64_t</code> respectively, allowing for character arrays up to 65,536 bytes, 4,294,967,296 bytes, and 18,446,744,073,709,551,616 bytes. Thus, the metadata for these types consumes 2, 4, and 8 bytes of memory respectively.</p>
<p>The reason for these different structures is to efficiently handle strings of varying sizes and save memory. If all structures used <code>uint64_t</code> for <code>len</code> and <code>alloc</code>, even small strings would waste memory. For example, with a 10-byte string, a <code>uint64_t</code> header would consume 16 bytes, which is inefficient. </p>
<p>Additionally, Redis uses compiler optimizations to further reduce memory usage. For the <code>sdshdr8</code> structure, it uses the <code>__attribute__((__packed__))</code> directive to prevent the compiler from aligning the structure to 8-byte boundaries. This packed attribute ensures that memory is allocated more compactly, avoiding the default 8-byte alignment that would waste space even if a variable is smaller than 8 bytes.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span></span></span><br></pre></td></tr></table></figure>
<p>To help you understand, let me give you an example. Suppose I define a structure <code>s1</code> with two member variables: one of type <code>char</code> and the other of type <code>int</code>, like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s1</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">    &#125; ts1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(ts1));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Although <code>char</code> takes up 1 byte and <code>int</code> takes up 4 bytes, if you run this code, you’ll notice that the total size printed is 8 bytes. This is because, by default, the compiler allocates 8 bytes to the <code>s1</code> structure, leaving 3 bytes unused due to padding.</p>
<p>To optimize memory usage, Redis takes a very efficient approach. It uses the <code>__attribute__((__packed__))</code> attribute to define structures, ensuring the compiler only allocates exactly the amount of memory needed for the structure’s fields.</p>
<p>For example, if I define another structure <code>s2</code> with the same <code>char</code> and <code>int</code> fields, but use the <code>__attribute__((__packed__))</code> attribute, the code would look like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">s2</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">    &#125; ts2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(ts2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When you run this code, the printed result is 5 bytes, indicating that the compiler has packed the structure more tightly, using only 5 bytes of memory.</p>
<p>In summary, if you’re developing a program and want to minimize the memory footprint of your data structures, you can use the <code>__attribute__((__packed__))</code> technique to achieve this.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this lesson, I introduced you to the design and implementation of strings in Redis. It’s important to understand that string implementations need to prioritize efficiency, support storing any type of binary data, and minimize memory usage. Redis’ approach to string design is definitely something worth studying and applying.</p>
<p>There are three key points you should focus on:</p>
<ol>
<li>The limitations of using <code>char*</code> to implement strings in C. Since <code>char*</code> relies on the <code>\0</code> character to indicate the end of a string, operations often require scanning the entire string, which isn’t efficient. Moreover, it can’t fully represent data that contains <code>\0</code>, which doesn’t meet Redis’ needs.</li>
<li>The design principles and implementation of strings in Redis. Redis introduces a specialized data structure called SDS (Simple Dynamic String), which builds on character arrays by adding metadata like the length of the string and the size of the allocated space. This allows operations like appending, copying, and comparing strings to be done by directly reading the metadata, improving efficiency. SDS also doesn’t use the <code>\0</code> character to mark the end of the string, treating it as binary data, which allows for storing things like images.</li>
<li>SDS uses different types to represent strings of varying sizes and employs the <code>__attribute__((__packed__))</code> technique to achieve a compact memory layout, helping to save memory.</li>
</ol>
<p>While strings may seem simple, today’s lesson shows that implementing them involves thoughtful design. The differences and similarities between C’s <code>char*</code> strings and Redis’ SDS are often asked about in Redis interviews, so I hope you’ll master these distinctions through this lesson.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com">Johnson Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com/2024/09/10/analyzing-redis-source-code-sds/">http://linjiangxiong.com/2024/09/10/analyzing-redis-source-code-sds/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="/image/redis-src/24091002.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/11/analyzing-redis-source-code-hash/" title="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing"><img class="cover" src="/image/redis-src/2024091101.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing</div></div><div class="info-2"><div class="info-item-1"> Redis offers a classic implementation of hash tables. To handle hash collisions, Redis employs chained hashing, which links data with the same hash value in a list rather than expanding the table. This ensures that all data remains accessible within the hash table. To minimize the performance impact of rehashing, Redis uses a incremental rehashing strategy, which distributes the workload of rehashing over time to reduce system overhead.  In this article, I’ll guide you through the core...</div></div></div></a><a class="pagination-related" href="/2024/09/06/why-does-redis-use-the-sds-structure-for-strings-instead-of-char/" title="Why Does Redis Use the SDS Structure for Strings Instead of char*?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Why Does Redis Use the SDS Structure for Strings Instead of char*?</div></div><div class="info-2"><div class="info-item-1">Redis, known for its performance and efficiency, uses a data structure called SDS (Simple Dynamic String) for handling strings in its key-value pairs rather than the traditional C string (char*). Understanding why this decision was made requires a look into both how Redis operates and the limitations of the C string. What is char* (C String)?In C, strings are represented as arrays of characters terminated by a null character (\0). While simple and efficient for static, unchanging strings,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2019/09/03/redis-batch-delete/" title="Redis根据通配符批量删除Key"><img class="cover" src="https://i.loli.net/2021/07/19/4eRMmKi3gvOHFlf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-03</div><div class="info-item-2">Redis根据通配符批量删除Key</div></div><div class="info-2"><div class="info-item-1">Redis 目前还不支持根据通配符批量删除 Key 的命令，但我们可以借助 Redis 的 del 命令、Linux 管道和 xargs 指令来完成。  Redis的 del 命令支持删除给定的一个或多个 key，并返回被删除 key 的数量。如命令 del key1 key2 key3。  比如要删除所有以 WxMpSessionKey 开头的 Key，可以使用如下命令： 12[redis@iztz9ploifbvce ~]# redis-cli -h 192.168.182.227 -p 1379 keys &quot;WxMpSessionKey*&quot; |xargs redis-cli -h 192.168.182.227 -p 1379 del(integer) 2674 如果连接 Redis 的 HOST 为 127.0.0.1，端口号也为默认的 6379，则以上的命令可以简写为： 1redis-cli keys &quot;WxMpSessionKey*&quot; |xargs redis-cli del （END） </div></div></div></a><a class="pagination-related" href="/2019/12/19/spring-boot-2_x-redis/" title="Spring Boot 2.x 集成Redis示例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-19</div><div class="info-item-2">Spring Boot 2.x 集成Redis示例</div></div><div class="info-2"><div class="info-item-1">一、如何集成首先，在 pom 文件新增 redis 依赖： 1234&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 接着修改项目配置文件 application.properties，增加 redis 配置 1234# redis hostspring.redis.host=172.24.58.226# redis portspring.redis.port=6379 经过上面简单的两步，即可在项目中使用 StringRedisTemplate 和 RedisTemplate&lt;Object,Object&gt;，因为从 Spring Boot 2.0 开始，Spring...</div></div></div></a><a class="pagination-related" href="/2024/06/02/using-the-pfadd-command-in-redis/" title="Using the PFADD Command in Redis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="info-item-2">Using the PFADD Command in Redis</div></div><div class="info-2"><div class="info-item-1">Redis, an open-source, in-memory data structure store, offers a wide range of commands to manipulate data structures like strings, lists, sets, hashes, bitmaps, hyperloglogs, and more. Among these, the HyperLogLog data type is particularly useful for approximating the number of unique elements in a set when the set is too large to fit into memory or when you don’t need absolute accuracy. The PFADD command is one of the key operations for working with HyperLogLog in Redis. This guide will...</div></div></div></a><a class="pagination-related" href="/2024/07/25/how-to-learn-redis-effectively/" title="How to learn Redis effectively?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-25</div><div class="info-item-2">How to learn Redis effectively?</div></div><div class="info-2"><div class="info-item-1">Redis, an open-source, high-performance in-memory data structure store, is renowned for its speed, versatility, and simplicity. It has gained immense popularity and is widely utilized for caching, distributed locks, session management, real-time analytics, and more. Whether you’re a developer looking to expand your skills or an IT professional aiming to optimize data handling, mastering Redis can significantly enhance your proficiency. Here’s a comprehensive guide on how to learn Redis...</div></div></div></a><a class="pagination-related" href="/2024/07/27/flushing-cache-data-in-redis-a-step-by-step-guide/" title="Flushing Cache Data in Redis: A Step-by-Step Guide"><img class="cover" src="/image/2024/07/2024072701.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="info-item-2">Flushing Cache Data in Redis: A Step-by-Step Guide</div></div><div class="info-2"><div class="info-item-1">Caching mechanisms are vital for optimizing application performance by storing frequently accessed data in-memory. Redis, as a robust key-value store, offers powerful caching capabilities. Occasionally, you might need to clear or flush all cached data from Redis to ensure consistency or during maintenance tasks. Here’s how you can do it effectively:  Understanding Redis FlushingFlushing in Redis refers to the action of removing all data stored in the current database. This operation is...</div></div></div></a><a class="pagination-related" href="/2024/07/30/effective-ways-to-delete-fuzzy-matching-keys-in-redis/" title="Effective Ways to Delete Fuzzy Matching Keys in Redis"><img class="cover" src="/image/2024/07/fuzzy-matching.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-30</div><div class="info-item-2">Effective Ways to Delete Fuzzy Matching Keys in Redis</div></div><div class="info-2"><div class="info-item-1">In Redis, managing keys efficiently is crucial for optimal performance. Sometimes, you might need to delete keys that match a pattern or have a fuzzy match. Here’s how you can achieve this: Using Redis CLI CommandsRedis CLI provides several commands to interact with keys. To delete keys that match a pattern, you can use the KEYS command in combination with the DEL command: 1redis-cli KEYS &quot;pattern*&quot; | xargs redis-cli DEL Replace &quot;pattern*&quot; with your specific pattern. This...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/IMG_3665.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Johnson Lin</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">476</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iuiuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/iuiuu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:me@linjiangxiong.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E2%80%99s-Requirements-for-Strings"><span class="toc-number">1.</span> <span class="toc-text">Redis’s Requirements for Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Support-for-a-Wide-Range-of-Efficient-String-Operations"><span class="toc-number">1.1.</span> <span class="toc-text">1. Support for a Wide Range of Efficient String Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Ability-to-Handle-Arbitrary-Binary-Data"><span class="toc-number">1.2.</span> <span class="toc-text">2. Ability to Handle Arbitrary Binary Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Minimizing-Memory-Overhead"><span class="toc-number">1.3.</span> <span class="toc-text">3. Minimizing Memory Overhead</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-doesn%E2%80%99t-Redis-Use-char"><span class="toc-number">2.</span> <span class="toc-text">Why doesn’t Redis Use char*?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Design-of-char-Struct"><span class="toc-number">2.1.</span> <span class="toc-text">The Design of char* Struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Complexity-of-String-Operations"><span class="toc-number">2.2.</span> <span class="toc-text">The Complexity of String Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Design-Philosophy-of-SDS"><span class="toc-number">3.</span> <span class="toc-text">Design Philosophy of SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS-Structure-Design"><span class="toc-number">3.1.</span> <span class="toc-text">SDS Structure Design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS-Operation-Efficiency"><span class="toc-number">3.2.</span> <span class="toc-text">SDS Operation Efficiency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Programming-Techniques-for-Compact-String-Structures"><span class="toc-number">3.3.</span> <span class="toc-text">Programming Techniques for Compact String Structures</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">4.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/17/a-complete-guide-to-base64-encoding-and-decoding/" title="A Complete Guide to Base64 Encoding and Decoding">A Complete Guide to Base64 Encoding and Decoding</a><time datetime="2025-01-16T20:50:51.000Z" title="Created 2025-01-17 04:50:51">2025-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/04/how-to-install-openjdk-17-on-ubuntu-24-0-4/" title="How to Install OpenJDK 17 on Ubuntu 24.0.4">How to Install OpenJDK 17 on Ubuntu 24.0.4</a><time datetime="2025-01-04T15:18:21.000Z" title="Created 2025-01-04 23:18:21">2025-01-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/03/install-openjdk-17-on-ubuntu/" title="Install OpenJDK 17 LTS on Ubuntu 24.04|22.04|20.04|18.04">Install OpenJDK 17 LTS on Ubuntu 24.04|22.04|20.04|18.04</a><time datetime="2025-01-02T16:21:33.000Z" title="Created 2025-01-03 00:21:33">2025-01-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/install-java-jdk-21-openjdk-21-on-ubuntu/" title="Install OpenJDK 21 LTS on Ubuntu 24.04|22.04|20.04|18.04">Install OpenJDK 21 LTS on Ubuntu 24.04|22.04|20.04|18.04</a><time datetime="2024-12-31T16:11:16.000Z" title="Created 2025-01-01 00:11:16">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/09/what-is-pagefile-sys-in-windows/" title="What is pagefile.sys in Windows, and should it be deleted?">What is pagefile.sys in Windows, and should it be deleted?</a><time datetime="2024-12-08T21:02:50.000Z" title="Created 2024-12-09 05:02:50">2024-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Johnson Lin</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/main.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>