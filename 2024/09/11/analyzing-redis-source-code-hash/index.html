<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing | Johnson Lin</title><meta name="author" content="Johnson Lin"><meta name="copyright" content="Johnson Lin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="keywords" content="Java,JVM,Spring,Spring Boot,Flink,Hadoop,Yarn,MySQL,Elasticsearch,Python,Kafka,Maven,Hbase,Kibana,Logstash,Tutorial,Technical Blogs,Data Structures,Algorithms,C,SQL,Data Science,Web Development,System Design,Interview Experience,Interview Preparation,Programming,Competitive Programming,Coding Contests,HTML,CSS,Computer Science,Programming Examples,Mathematics"><meta name="description" content="Redis offers a classic implementation of hash tables. To handle hash collisions, Redis employs chained hashing, which links data with the same hash value in a list rather than expanding the table. Th">
<meta property="og:type" content="article">
<meta property="og:title" content="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing">
<meta property="og:url" content="http://linjiangxiong.com/2024/09/11/analyzing-redis-source-code-hash/index.html">
<meta property="og:site_name" content="Johnson Lin">
<meta property="og:description" content="Redis offers a classic implementation of hash tables. To handle hash collisions, Redis employs chained hashing, which links data with the same hash value in a list rather than expanding the table. Th">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://linjiangxiong.com/image/redis-src/2024091101.png">
<meta property="article:published_time" content="2024-09-10T22:28:03.000Z">
<meta property="article:modified_time" content="2024-09-13T14:47:15.669Z">
<meta property="article:author" content="Johnson Lin">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://linjiangxiong.com/image/redis-src/2024091101.png"><link rel="shortcut icon" href="/image/IMG_3665.JPG"><link rel="canonical" href="http://linjiangxiong.com/2024/09/11/analyzing-redis-source-code-hash/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&amp;family=Source+Sans+3:wght@400;600&amp;display=swap"><link rel="stylesheet" href="/css/ud_v5.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ca45da0012a3ce293c6ca4f7e5ebc3a8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc');
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-13 22:47:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/IMG_3665.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">294</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Johnson Lin"><span class="site-name">Johnson Lin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-10T22:28:03.000Z" title="Created 2024-09-11 06:28:03">2024-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-13T14:47:15.669Z" title="Updated 2024-09-13 22:47:15">2024-09-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis-Source-Code-Analysis/">Redis Source Code Analysis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>Redis offers a classic implementation of hash tables. To handle hash collisions, Redis employs chained hashing, which links data with the same hash value in a list rather than expanding the table. This ensures that all data remains accessible within the hash table. To minimize the performance impact of rehashing, Redis uses a incremental rehashing strategy, which distributes the workload of rehashing over time to reduce system overhead.</p>
</blockquote>
<p>In this article, I’ll guide you through the core design principles and implementation details of Redis hash tables. By understanding how Redis manages hash collisions and optimizes rehashing, you’ll gain the tools to implement high-performance hash tables when handling large datasets in practical applications.</p>
<h2 id="How-does-Redis-Implement-Chained-Hashing"><a href="#How-does-Redis-Implement-Chained-Hashing" class="headerlink" title="How does Redis Implement Chained Hashing?"></a>How does Redis Implement Chained Hashing?</h2><p>Before we dive into Redis’ implementation of chained hashing, it’s essential to first understand the structure of Redis hash tables and the cause of hash collisions as data volume increases. This context will help clarify how chained hashing effectively addresses these collisions.</p>
<h3 id="What-is-a-Hash-Collision"><a href="#What-is-a-Hash-Collision" class="headerlink" title="What is a Hash Collision?"></a>What is a Hash Collision?</h3><p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">At its core, a hash table is an array where each element represents a hash bucket. The first element is bucket 0, the second is bucket 1, and so on. When a key-value pair is inserted, the key is processed by a hash function, and the result is taken modulo the number of elements in the array. This gives the index (or bucket) where the key-value pair will be stored.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">For example, as shown in the diagram below, after hashing </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key1&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, it maps to bucket 1. Similarly, </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key3&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key16&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> map to buckets 7 and 4, respectively.</font></p>
<p><img src="/image/redis-src/2024091101.png"></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">From the diagram, we see that there are 16 keys to store, but the hash table only has 8 available slots. This leads to a situation where multiple keys are assigned to the same bucket, resulting in a hash collision.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">In practical use, it’s often difficult to predict exactly how much data will need to be stored in a hash table. Creating an oversized hash table upfront can lead to wasted space if the data volume remains low. For this reason, hash tables are typically initialized with a smaller size, with the expectation that the number of keys (keyspace) will eventually outgrow the initial table size.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">This mismatch between keyspace and hash table size inevitably causes different keys to be mapped to the same bucket by the hash function, resulting in hash collisions. If each bucket can only store a single key-value pair, this limits the hash table’s ability to manage large datasets effectively. For example, if both </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key3&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key100&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> are mapped to bucket 5, and bucket 5 can only hold one key, one of the keys would fail to be stored in the hash table.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><img src="/image/redis-src/2024091102.png"></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">To resolve hash collisions, two common solutions are used:</font></p>
<ol>
<li><strong><font style="background-color:rgb(249, 250, 251);">Chaining</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, which I’ll introduce next, allows multiple keys to be stored in the same bucket by linking them in a list. However, it’s important to ensure that chains don’t become too long, as this can degrade the hash table’s performance.</font></li>
<li><strong><font style="background-color:rgb(249, 250, 251);">Rehashing</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, which redistributes the keys when the chain length exceeds a certain threshold. Rehashing can be costly, but Redis mitigates this with incremental rehashing, which spreads the rehashing process over time.</font></li>
</ol>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Let’s now explore how chained hashing is designed and implemented to handle hash collisions.</font></p>
<h3 id="How-is-Chained-Hashing-Designed-and-Implemented"><a href="#How-is-Chained-Hashing-Designed-and-Implemented" class="headerlink" title="How is Chained Hashing Designed and Implemented?"></a><font style="background-color:rgb(249, 250, 251);">How is Chained Hashing Designed and Implemented?</font></h3><p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Chained hashing is a technique where keys mapped to the same bucket in a hash table are linked together using a linked list. Let’s explore how Redis implements chained hashing and why it’s effective in resolving hash collisions.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">First, we need to understand how the hash table is implemented in Redis. The source code related to Redis’s hash table can be found in two main files: </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dict.h&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dict.c&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. The </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dict.h&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> file defines the structure of the hash table, hash entries, and various operation functions, while </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dict.c&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> contains the actual implementation of these operations.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">In </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dict.h&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, the hash table is defined as a two-dimensional array (</font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictEntry **table&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">), where each element is a pointer to a hash entry (</font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictEntry&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">). The following code snippet shows how the hash table is defined in </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dict.h&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">To implement chained hashing, Redis’s </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictEntry&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> structure is designed to include a pointer not only to the key and value but also to the next hash entry. This is what creates the linked list for handling collisions. As shown in the code, the </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictEntry&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> structure includes a pointer, </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;*next&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, which points to another </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictEntry&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> structure—this is how Redis implements chained hashing.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">In addition to the </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;next&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> pointer for chaining, there’s another interesting detail worth noting. The value in the key-value pair is defined by a union, </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;v&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, in the </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictEntry&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> structure. This union includes a pointer to the actual value (</font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;*val&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">), as well as fields for storing an unsigned 64-bit integer, a signed 64-bit integer, or a </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;double&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> value.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">The reason I’m pointing this out is that this design choice is a clever memory-saving technique. When the value is an integer or a double, which are 64-bit types, there’s no need for an additional pointer to store the value. Instead, the value can be stored directly within the key-value structure, reducing the need for extra memory.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">At this point, you should have a solid understanding of how Redis implements chained hashing. But you might still be wondering how this helps resolve hash collisions. </font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Let me explain using an example: both </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key3&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key100&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> are mapped to bucket 5 in the hash table. With chained hashing, bucket 5 doesn’t just store </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key3&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> or </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key100&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">—instead, it uses a linked list to connect </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key3&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key100&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, as shown in the diagram below. As more keys are mapped to bucket 5, they are all linked together in a list, thus managing the collisions.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><img src="/image/redis-src/2024091103.png"></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">When we want to search for </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key100&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, we start by computing its hash value and finding that it maps to bucket 5. We then traverse the linked list in bucket 5, comparing each key until we find </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;key100&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. This is how chained hashing allows us to resolve collisions and locate the desired entry.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">However, there is a drawback to chained hashing. As the linked list in a single bucket grows longer, the time it takes to search for a key in that bucket increases, which can degrade the overall performance of the hash table.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">So, is there a way to minimize the performance impact? Yes! That brings us to the next topic: the design and implementation of </font><em><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">rehashing</font></em><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<h2 id="How-does-Redis-Implement-Rehashing"><a href="#How-does-Redis-Implement-Rehashing" class="headerlink" title="How does Redis Implement Rehashing?"></a>How does Redis Implement Rehashing?</h2><p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Rehashing in Redis essentially refers to expanding the size of the hash table. The basic approach Redis takes to implement rehashing is as follows:</font></p>
<ol>
<li><strong>Redis uses two hash tables alternately during rehashing</strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. As I mentioned earlier, Redis defines the hash table using the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictht&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> structure in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dict.h&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. However, when actually using the hash table, Redis also defines a </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dict&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> structure in the same file. This structure contains an array (</font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[2]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">) with two hash tables: </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. The </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dict&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> structure is defined in the code as follows:</font></li>
</ol>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<ol start="2">
<li>**During normal operation, all key-value pairs are written to **<code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">.</font></li>
<li><strong>When rehashing occurs</strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, key-value pairs are gradually migrated from </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> to </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">.</font></li>
<li><strong>After migration is complete</strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, the memory space of </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is released, and the address of </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is assigned to </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. Then, the size of </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is reset to zero. At this point, Redis resumes normal operations, with </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> handling requests and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> reserved for the next rehash.</font></li>
</ol>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">To help you understand this alternating process between </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, I’ve included a diagram below.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><img src="/image/redis-src/2024091104.png"></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Now that you have a basic understanding of how Redis alternates between two hash tables to implement rehashing, let’s discuss some important questions that need to be addressed during rehashing. I believe there are three key issues to consider:</font></p>
<ol>
<li><strong>When should rehashing be triggered?</strong></li>
<li><strong>How much should the hash table be expanded?</strong></li>
<li><strong>How should rehashing be carried out?</strong></li>
</ol>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Next, I’ll walk you through the code implementation for each of these questions, so you can clearly see how Redis handles these aspects of rehashing.</font></p>
<h3 id="When-Should-Rehashing-Be-Triggered"><a href="#When-Should-Rehashing-Be-Triggered" class="headerlink" title="When Should Rehashing Be Triggered?"></a>When Should Rehashing Be Triggered?</h3><p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">To determine when rehashing is needed, Redis uses the function </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictExpandIfNeeded&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. Let’s first look at the conditions within this function that trigger resizing, and then explore where this function is called in the Redis codebase.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">There are three conditions defined in the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictExpandIfNeeded&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function that can trigger expansion:</font></p>
<ol>
<li><strong>Condition 1</strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">: The size of </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is zero.</font></li>
<li><strong>Condition 2</strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">: The number of elements in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> exceeds its current size, and the hash table can be resized.</font></li>
<li><strong>Condition 3</strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">: The number of elements in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is a multiple of the table size, defined by </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dict_force_resize_ratio&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> (which defaults to 5).</font></li>
</ol>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Here’s a snippet of the code defining these conditions in the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictExpandIfNeeded&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function:</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictTypeExpandAllowed(d))</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    <span class="keyword">if</span> ((dict_can_resize == DICT_RESIZE_ENABLE &amp;&amp;</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size) ||</span><br><span class="line">        (dict_can_resize != DICT_RESIZE_FORBID &amp;&amp;</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used / d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">For the first condition, if the hash table is empty, Redis simply sets the table to its initial size, which is part of initialization, not rehashing. </font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Conditions two and three, however, correspond to rehashing scenarios. In both cases, Redis compares the number of elements in the hash table (</font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;d-&gt;ht[0].used&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">) with the table’s current size (</font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;d-&gt;ht[0].size&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">). This ratio is known as the </font><strong>load factor</strong><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. Redis triggers rehashing when the load factor is either equal to or greater than 1, or greater than 5.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">When the load factor exceeds 5, it indicates that the hash table is severely overloaded and needs to be resized immediately. If the load factor is 1 or greater, Redis checks the value of the variable </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dict_can_resize&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> to determine if resizing is currently allowed.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">You may wonder, what exactly is the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dict_can_resize&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> variable? This variable is controlled by two functions: </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictEnableResize&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictDisableResize&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, which enable and disable hash table resizing, respectively:</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dictEnableResize</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictDisableResize</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">These functions are wrapped within </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;updateDictResizePolicy&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. This function enables or disables rehashing based on whether Redis is currently running an RDB snapshot or AOF rewrite process. If neither process is running, rehashing is allowed:</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">updateDictResizePolicy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</span><br><span class="line">        dictEnableResize();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dictDisableResize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Now that we understand the conditions for triggering rehashing in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictExpandIfNeeded&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, let’s look at where this function is called in Redis. By examining the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dict.c&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> file, we can see that </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictExpandIfNeeded&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is invoked by the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictKeyIndex&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function, which is itself called by </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictAddRaw&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. The </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictAddRaw&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function is then called by three key functions:</font></p>
<ol>
<li><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictAdd&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">: Adds a key-value pair to the hash table.</font></li>
<li><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictReplace&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">: Adds a key-value pair or replaces an existing one.</font></li>
<li><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictAddOrFind&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">: Calls </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictAddRaw&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> directly.</font></li>
</ol>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Thus, every time Redis adds or modifies a key-value pair, it checks whether rehashing is necessary. The following diagram illustrates the call relationships leading to </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictExpandIfNeeded&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><img src="/image/redis-src/2024091105.png"></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">In summary, the key functions responsible for triggering rehashing in Redis are </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictExpandIfNeeded&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;updateDictResizePolicy&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. The former checks the load factor and whether resizing is allowed, while the latter enables or disables resizing based on RDB and AOF processes.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Next, we’ll explore the second major question in rehashing: </font><strong>how much should Redis expand the hash table?</strong></p>
<h3 id="How-Much-Should-the-Hash-Table-Be-Expanded"><a href="#How-Much-Should-the-Hash-Table-Be-Expanded" class="headerlink" title="How Much Should the Hash Table Be Expanded?"></a>How Much Should the Hash Table Be Expanded?</h3><p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">In Redis, when resizing the hash table space due to rehashing, it calls the </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictExpand&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function. This function takes two parameters: the hash table to be resized (</font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dict *d&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">) and the target size (</font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;unsigned long size&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">). The prototype of the </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictExpand&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function is shown below:</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">To determine whether resizing is needed for a hash table, we use the </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;_dictExpandIfNeeded&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function. Once resizing is deemed necessary, Redis expands the hash table during rehashing by doubling its current size (</font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;size * 2&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">) if the current table’s used space is </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;size&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, as illustrated in the following code snippet:</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">The actual resizing process in the </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;dictExpand&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function is managed by the </font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;_dictNextPower&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function. This function continuously doubles the hash table’s initial size (</font><code>**&lt;font style=&quot;background-color:rgb(249, 250, 251);&quot;&gt;DICT_HT_INITIAL_SIZE&lt;/font&gt;**</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">) until it reaches the target size, as shown in the code snippet below:</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> _dictNextPower(<span class="type">unsigned</span> <span class="type">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX + <span class="number">1LU</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Now, let’s delve into Redis’s approach to addressing the third issue: how to execute rehashing. Essentially, this involves Redis implementing a incremental rehashing design.</font></p>
<h3 id="How-is-Incremental-Rehashing-Implemented"><a href="#How-is-Incremental-Rehashing-Implemented" class="headerlink" title="How is Incremental Rehashing Implemented?"></a><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">How is Incremental Rehashing Implemented?</font></h3><p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">First, let’s clarify why we need incremental rehashing in the first place. When a hash table undergoes rehashing, the hash table space expands, and keys that were mapped to certain positions may now need to be relocated to new ones. This means many keys must be copied from their old positions to new ones. During this key copying process, Redis’s main thread is unable to handle other requests, causing the rehashing process to block the main thread and lead to performance overhead.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">To mitigate this overhead, Redis introduced the concept of incremental rehashing.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">In simple terms, incremental rehashing means Redis doesn’t copy all the keys from the current hash table to the new one in a single operation. Instead, it copies them in batches, with each operation only transferring keys from one bucket at a time. This limits the duration of each copying operation, thereby reducing its impact on the main thread.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">So, how is incremental rehashing implemented in the code? There are two key functions involved: </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictRehashStep&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Let’s start with the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function, which performs the actual key copying. It takes two input parameters: the global hash table (which consists of the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dict&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> structure holding </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">) and the number of buckets to be rehashed.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">The logic of the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function is divided into two parts:</font></p>
<ol>
<li><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">First, it runs a loop, copying the keys in each bucket according to the specified number of buckets </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;n&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. Of course, if all the data in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> has already been transferred, the copying loop stops.</font></li>
<li><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Second, after copying </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;n&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> buckets, the function checks whether all the data in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> has been migrated. If so, the space for </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is released. Since Redis always references </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> when handling requests, once the rehashing process is complete and the data is fully in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, Redis assigns </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> to </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, ensuring that other parts of the code can continue functioning as expected. After this, the size of </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is reset to zero in preparation for the next rehash. At the same time, the global hash table’s </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> variable is set to -1, indicating that the rehash process has finished (I’ll explain the purpose of the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> variable shortly).</font></li>
</ol>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Here’s a diagram that illustrates the primary steps of the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function. </font></p>
<p><img src="/image/redis-src/2024091106.png"></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">You can also check the code snippet below to better understand its logic.</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s0 = d-&gt;ht[<span class="number">0</span>].size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s1 = d-&gt;ht[<span class="number">1</span>].size;</span><br><span class="line">    <span class="keyword">if</span> (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dict_can_resize == DICT_RESIZE_AVOID &amp;&amp; </span><br><span class="line">        ((s1 &gt; s0 &amp;&amp; s1 / s0 &lt; dict_force_resize_ratio) ||</span><br><span class="line">         (s1 &lt; s0 &amp;&amp; s0 / s1 &lt; dict_force_resize_ratio)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Now that we’ve covered the core functionality of the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function, let’s explore how incremental rehashing works by migrating data at the bucket level. This is where the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> variable in the global hash table structure comes into play.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">The </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> variable indicates which bucket is currently being migrated. For instance, when </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is 0, the first bucket in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is being migrated; when it’s 1, the second bucket is being migrated, and so on.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">The main loop in the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function checks whether the bucket pointed to by </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is empty. If it is, </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is incremented, and the next bucket is examined.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">But is it possible for multiple consecutive buckets to be empty? Yes, it is. In such cases, incremental rehashing doesn’t just keep incrementing </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> indefinitely. The reason is that during rehashing, the Redis main thread is unable to handle other requests. Therefore, Redis introduces a variable called </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;empty_visits&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> to track how many empty buckets have been checked. After a certain number of empty buckets have been examined, the current round of rehashing stops, allowing Redis to process external requests and avoid performance degradation. You can see this logic in the code snippet below.</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    d-&gt;rehashidx++;</span><br><span class="line">    <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">If the bucket that </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> points to contains data for migration, Redis will take each hash entry from that bucket, recalculate its new position in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> based on the size of </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, and insert the hash entry into the appropriate bucket in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. Each time a hash entry is migrated, the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;used&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> variables in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> (which track how many entries each table holds) are updated—</font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;used&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[0]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> decreases by one, while </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;used&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> in </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;ht[1]&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> increases by one. Once all data in the current bucket is migrated, </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;rehashidx&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is incremented, and the process continues with the next bucket. The code snippet below illustrates this migration process.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">By now, we’ve covered the complete logic of the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function. We know that </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> migrates hash entries on a bucket-by-bucket basis, with the number of buckets processed being determined by the loop count parameter </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;n&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">. Whenever Redis performs a rehash operation, it eventually calls the </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> function.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Next, let’s look at the second key function involved in incremental rehashing: </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictRehashStep&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, which performs rehashing one bucket at a time. According to Redis’s source code, there are five functions that call </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictRehashStep&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, which in turn calls </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> to carry out the rehashing process. These functions are: </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictAddRaw&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictGenericDelete&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictFind&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictGetRandomKey&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictGetSomeKeys&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">The functions </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictAddRaw&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> and </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictGenericDelete&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> are used to add and delete key-value pairs in Redis, while the other three functions are for querying. The diagram below shows the relationships between these functions.</font></p>
<p><img src="/image/redis-src/2024091107.png"></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">It’s important to note that regardless of whether you’re adding, deleting, or querying, when these five functions call </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;_dictRehashStep&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">, the loop count parameter </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;n&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> passed to </font><code>&lt;font style=&quot;color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);&quot;&gt;dictRehash&lt;/font&gt;</code><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"> is always set to 1, as shown in the following code:</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="comment">// Passes 1 as the loop count parameter to `dictRehash`, meaning that after migrating one bucket, normal operations resume</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">This means that after migrating a single bucket, the hash table is free to handle regular add, delete, or query operations. This is how incremental rehashing is implemented at the code level.</font></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">Creating a high-performance hash table is not only a priority for Redis but also a crucial goal in the development of many computer systems. To build an efficient hash table, two key issues need to be addressed: hash collisions and the overhead of rehashing.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">In this article, we explored the structure of Redis’s hash table, the implementation of chained hashing, and the design and implementation of incremental rehashing. Redis’s hash table structure is unique—each hash entry contains a pointer, enabling chained hashing. Additionally, Redis uses a global hash table that contains two hash tables, a design that facilitates data migration from one table to another during rehashing.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);">The incremental rehashing mechanism in Redis is a general method for hash table expansion and is worth studying. Its core idea is to migrate only a limited number of buckets at a time, preventing performance issues that arise from migrating all buckets in one go. Once you understand the concept and implementation of incremental rehashing, you can apply it to your own hash table designs.</font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
<p><font style="color:rgb(55, 65, 81);background-color:rgb(249, 250, 251);"></font></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com">Johnson Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com/2024/09/11/analyzing-redis-source-code-hash/">http://linjiangxiong.com/2024/09/11/analyzing-redis-source-code-hash/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/image/redis-src/2024091101.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/18/bulk-deleting-keys-in-redis-using-wildcards/" title="Bulk Deleting Keys in Redis Using Wildcards"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Bulk Deleting Keys in Redis Using Wildcards</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/10/analyzing-redis-source-code-sds/" title="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation"><img class="cover" src="/image/redis-src/24091002.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/08/25/flush-all-cache-data-in-redis/" title="【Redis】flushall命令——清空所有缓存数据"><img class="cover" src="/image/brand/redis.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">【Redis】flushall命令——清空所有缓存数据</div></div></a></div><div><a href="/2024/06/02/using-the-pfadd-command-in-redis/" title="Using the PFADD Command in Redis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">Using the PFADD Command in Redis</div></div></a></div><div><a href="/2024/07/30/effective-ways-to-delete-fuzzy-matching-keys-in-redis/" title="Effective Ways to Delete Fuzzy Matching Keys in Redis"><img class="cover" src="/image/2024/07/fuzzy-matching.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-30</div><div class="title">Effective Ways to Delete Fuzzy Matching Keys in Redis</div></div></a></div><div><a href="/2024/07/27/flushing-cache-data-in-redis-a-step-by-step-guide/" title="Flushing Cache Data in Redis: A Step-by-Step Guide"><img class="cover" src="/image/2024/07/2024072701.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="title">Flushing Cache Data in Redis: A Step-by-Step Guide</div></div></a></div><div><a href="/2024/07/29/a-set-of-best-practices-and-guidelines-for-using-redis-effectively/" title="A set of best practices and guidelines for using Redis effectively"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-29</div><div class="title">A set of best practices and guidelines for using Redis effectively</div></div></a></div><div><a href="/2024/07/25/how-to-learn-redis-effectively/" title="How to learn Redis effectively?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-25</div><div class="title">How to learn Redis effectively?</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/IMG_3665.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Johnson Lin</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">294</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iuiuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/iuiuu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:me@linjiangxiong.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#How-does-Redis-Implement-Chained-Hashing"><span class="toc-number">1.</span> <span class="toc-text">How does Redis Implement Chained Hashing?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-a-Hash-Collision"><span class="toc-number">1.1.</span> <span class="toc-text">What is a Hash Collision?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-is-Chained-Hashing-Designed-and-Implemented"><span class="toc-number">1.2.</span> <span class="toc-text">How is Chained Hashing Designed and Implemented?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-does-Redis-Implement-Rehashing"><span class="toc-number">2.</span> <span class="toc-text">How does Redis Implement Rehashing?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#When-Should-Rehashing-Be-Triggered"><span class="toc-number">2.1.</span> <span class="toc-text">When Should Rehashing Be Triggered?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-Much-Should-the-Hash-Table-Be-Expanded"><span class="toc-number">2.2.</span> <span class="toc-text">How Much Should the Hash Table Be Expanded?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-is-Incremental-Rehashing-Implemented"><span class="toc-number">2.3.</span> <span class="toc-text">How is Incremental Rehashing Implemented?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">3.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/18/bulk-deleting-keys-in-redis-using-wildcards/" title="Bulk Deleting Keys in Redis Using Wildcards">Bulk Deleting Keys in Redis Using Wildcards</a><time datetime="2024-09-18T15:42:56.000Z" title="Created 2024-09-18 23:42:56">2024-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/11/analyzing-redis-source-code-hash/" title="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing"><img src="/image/redis-src/2024091101.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing"/></a><div class="content"><a class="title" href="/2024/09/11/analyzing-redis-source-code-hash/" title="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing">Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing</a><time datetime="2024-09-10T22:28:03.000Z" title="Created 2024-09-11 06:28:03">2024-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/10/analyzing-redis-source-code-sds/" title="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation"><img src="/image/redis-src/24091002.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation"/></a><div class="content"><a class="title" href="/2024/09/10/analyzing-redis-source-code-sds/" title="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation">Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation</a><time datetime="2024-09-09T17:13:55.000Z" title="Created 2024-09-10 01:13:55">2024-09-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/06/why-does-redis-use-the-sds-structure-for-strings-instead-of-char/" title="Why Does Redis Use the SDS Structure for Strings Instead of char*?">Why Does Redis Use the SDS Structure for Strings Instead of char*?</a><time datetime="2024-09-05T16:01:26.000Z" title="Created 2024-09-06 00:01:26">2024-09-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/05/how-to-delete-data-in-elasticsearch-single-multiple-clear-and-all/" title="How to Delete Data in Elasticsearch: Single, Multiple, Clear, and All">How to Delete Data in Elasticsearch: Single, Multiple, Clear, and All</a><time datetime="2024-09-04T16:02:38.000Z" title="Created 2024-09-05 00:02:38">2024-09-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Johnson Lin</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/search/local-search.min.js"></script></div></div></body></html>