<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing | Johnson Lin</title><meta name="author" content="Johnson Lin"><meta name="copyright" content="Johnson Lin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis offers a classic implementation of hash tables. To handle hash collisions, Redis employs chained hashing, which links data with the same hash value in a list rather than expanding the table. Th">
<meta property="og:type" content="article">
<meta property="og:title" content="Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing">
<meta property="og:url" content="http://linjiangxiong.com/2024/09/11/analyzing-redis-source-code-hash/index.html">
<meta property="og:site_name" content="Johnson Lin">
<meta property="og:description" content="Redis offers a classic implementation of hash tables. To handle hash collisions, Redis employs chained hashing, which links data with the same hash value in a list rather than expanding the table. Th">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://linjiangxiong.com/image/redis-src/2024091101.png">
<meta property="article:published_time" content="2024-09-10T22:28:03.000Z">
<meta property="article:modified_time" content="2024-12-03T21:57:29.000Z">
<meta property="article:author" content="Johnson Lin">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://linjiangxiong.com/image/redis-src/2024091101.png"><link rel="shortcut icon" href="/image/IMG_3665.JPG"><link rel="canonical" href="http://linjiangxiong.com/2024/09/11/analyzing-redis-source-code-hash/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&amp;family=Source+Sans+3:wght@400;600&amp;display=swap"><link rel="stylesheet" href="/css/ud_v5.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ca45da0012a3ce293c6ca4f7e5ebc3a8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'WLKqFH01ST8bHfxLtjsterJZnoEpVlF26sn-Nzzoqfc', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/IMG_3665.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">488</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2025/01/29/ollama-tutorial/"><i class="fa-fw fas fa-book"></i><span> Ollama Tutorial</span></a></li><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/2024/08/27/yaml-tutorial/"><i class="fa-fw fas fa-book"></i><span> YAML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><span> Dev Wiki</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/11/29/wiki/standard-ascii-table/"><i class="fa-fw fas fa-book"></i><span> Standard ASCII Table (7-bit)</span></a></li><li><a class="site-page child" href="/2025/01/17/a-complete-guide-to-base64-encoding-and-decoding/"><i class="fa-fw fas fa-book"></i><span> Base64 Introduction</span></a></li><li><a class="site-page child" href="/2024/11/30/wiki/html-char/"><i class="fa-fw fas fa-book"></i><span> HTML Special Char</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><span> Dev Tools</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tools/json-formatter/"><i class="fa-fw fas fa-link"></i><span> JSON Format</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Johnson Lin</span></a><a class="nav-page-title" href="/"><span class="site-name">Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> Instant Tutorials</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2025/01/29/ollama-tutorial/"><i class="fa-fw fas fa-book"></i><span> Ollama Tutorial</span></a></li><li><a class="site-page child" href="/2024/06/29/html-instant-tutorial/"><i class="fa-fw fas fa-book"></i><span> HTML Tutorial</span></a></li><li><a class="site-page child" href="/2024/08/27/yaml-tutorial/"><i class="fa-fw fas fa-book"></i><span> YAML Tutorial</span></a></li><li><a class="site-page child" href="/categories/Bash-Tutorial/"><i class="fa-fw fas fa-book"></i><span> Bash Tutorial</span></a></li><li><a class="site-page child" href="/2023/09/05/tutorial-gson/"><i class="fa-fw fas fa-music"></i><span> 极简教程 - Gson</span></a></li><li><a class="site-page child" href="/categories/Redis%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-book"></i><span> Redis教程</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><span> Dev Wiki</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/2024/11/29/wiki/standard-ascii-table/"><i class="fa-fw fas fa-book"></i><span> Standard ASCII Table (7-bit)</span></a></li><li><a class="site-page child" href="/2025/01/17/a-complete-guide-to-base64-encoding-and-decoding/"><i class="fa-fw fas fa-book"></i><span> Base64 Introduction</span></a></li><li><a class="site-page child" href="/2024/11/30/wiki/html-char/"><i class="fa-fw fas fa-book"></i><span> HTML Special Char</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><span> Dev Tools</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tools/json-formatter/"><i class="fa-fw fas fa-link"></i><span> JSON Format</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Analyzing Redis Source Code: The Structure and Design of Hash Tables, Chained Hashing, and Incremental Rehashing</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-10T22:28:03.000Z" title="Created 2024-09-11 06:28:03">2024-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-12-03T21:57:29.000Z" title="Updated 2024-12-04 05:57:29">2024-12-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis-Source-Code-Analysis/">Redis Source Code Analysis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<p>Redis offers a classic implementation of hash tables. To handle hash collisions, Redis employs chained hashing, which links data with the same hash value in a list rather than expanding the table. This ensures that all data remains accessible within the hash table. To minimize the performance impact of rehashing, Redis uses a incremental rehashing strategy, which distributes the workload of rehashing over time to reduce system overhead.</p>
</blockquote>
<p>In this article, I’ll guide you through the core design principles and implementation details of Redis hash tables. By understanding how Redis manages hash collisions and optimizes rehashing, you’ll gain the tools to implement high-performance hash tables when handling large datasets in practical applications.</p>
<h2 id="How-does-Redis-Implement-Chained-Hashing"><a href="#How-does-Redis-Implement-Chained-Hashing" class="headerlink" title="How does Redis Implement Chained Hashing?"></a>How does Redis Implement Chained Hashing?</h2><p>Before we dive into Redis’ implementation of chained hashing, it’s essential to first understand the structure of Redis hash tables and the cause of hash collisions as data volume increases. This context will help clarify how chained hashing effectively addresses these collisions.</p>
<h3 id="What-is-a-Hash-Collision"><a href="#What-is-a-Hash-Collision" class="headerlink" title="What is a Hash Collision?"></a>What is a Hash Collision?</h3><p>At its core, a hash table is an array where each element represents a hash bucket. The first element is bucket 0, the second is bucket 1, and so on. When a key-value pair is inserted, the key is processed by a hash function, and the result is taken modulo the number of elements in the array. This gives the index (or bucket) where the key-value pair will be stored.<br>For example, as shown in the diagram below, after hashing key1, it maps to bucket 1. Similarly, key3 and key16 map to buckets 7 and 4, respectively.</p>
<p><img src="/image/redis-src/2024091101.png" alt=""></p>
<p>From the diagram, we see that there are 16 keys to store, but the hash table only has 8 available slots. This leads to a situation where multiple keys are assigned to the same bucket, resulting in a hash collision.</p>
<p>In practical use, it’s often difficult to predict exactly how much data will need to be stored in a hash table. Creating an oversized hash table upfront can lead to wasted space if the data volume remains low. For this reason, hash tables are typically initialized with a smaller size, with the expectation that the number of keys (keyspace) will eventually outgrow the initial table size.</p>
<p>This mismatch between keyspace and hash table size inevitably causes different keys to be mapped to the same bucket by the hash function, resulting in hash collisions. If each bucket can only store a single key-value pair, this limits the hash table’s ability to manage large datasets effectively. For example, if both key3 and key100 are mapped to bucket 5, and bucket 5 can only hold one key, one of the keys would fail to be stored in the hash table.</p>
<p><img src="/image/redis-src/2024091102.png" alt=""></p>
<p>To resolve hash collisions, two common solutions are used:</p>
<ol>
<li><strong>Chaining</strong>, which I’ll introduce next, allows multiple keys to be stored in the same bucket by linking them in a list. However, it’s important to ensure that chains don’t become too long, as this can degrade the hash table’s performance.</li>
<li><strong>Rehashing</strong>, which redistributes the keys when the chain length exceeds a certain threshold. Rehashing can be costly, but Redis mitigates this with incremental rehashing, which spreads the rehashing process over time.</li>
</ol>
<p>Let’s now explore how chained hashing is designed and implemented to handle hash collisions.</p>
<h3 id="How-is-Chained-Hashing-Designed-and-Implemented"><a href="#How-is-Chained-Hashing-Designed-and-Implemented" class="headerlink" title="How is Chained Hashing Designed and Implemented?"></a>How is Chained Hashing Designed and Implemented?</h3><p>Chained hashing is a technique where keys mapped to the same bucket in a hash table are linked together using a linked list. Let’s explore how Redis implements chained hashing and why it’s effective in resolving hash collisions.</p>
<p>First, we need to understand how the hash table is implemented in Redis. The source code related to Redis’s hash table can be found in two main files: <code>dict.h</code> and <code>dict.c</code>. The <code>dict.h</code> file defines the structure of the hash table, hash entries, and various operation functions, while <code>dict.c</code> contains the actual implementation of these operations.</p>
<p>In <code>dict.h</code>, the hash table is defined as a two-dimensional array (<code>dictEntry **table</code>), where each element is a pointer to a hash entry (<code>dictEntry</code>). The following code snippet shows how the hash table is defined in <code>dict.h</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>To implement chained hashing, Redis’s <code>dictEntry</code> structure is designed to include a pointer not only to the key and value but also to the next hash entry. This is what creates the linked list for handling collisions. As shown in the code, the <code>dictEntry</code> structure includes a pointer, <code>*next</code>, which points to another <code>dictEntry</code> structure—this is how Redis implements chained hashing.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>In addition to the <code>next</code> pointer for chaining, there’s another interesting detail worth noting. The value in the key-value pair is defined by a union, <code>v</code>, in the <code>dictEntry</code> structure. This union includes a pointer to the actual value (<code>*val</code>), as well as fields for storing an unsigned 64-bit integer, a signed 64-bit integer, or a <code>double</code> value.</p>
<p>The reason I’m pointing this out is that this design choice is a clever memory-saving technique. When the value is an integer or a double, which are 64-bit types, there’s no need for an additional pointer to store the value. Instead, the value can be stored directly within the key-value structure, reducing the need for extra memory.</p>
<p>At this point, you should have a solid understanding of how Redis implements chained hashing. But you might still be wondering how this helps resolve hash collisions. </p>
<p>Let me explain using an example: both <code>key3</code> and <code>key100</code> are mapped to bucket 5 in the hash table. With chained hashing, bucket 5 doesn’t just store <code>key3</code> or <code>key100</code>—instead, it uses a linked list to connect <code>key3</code> and <code>key100</code>, as shown in the diagram below. As more keys are mapped to bucket 5, they are all linked together in a list, thus managing the collisions.</p>
<p><img src="/image/redis-src/2024091103.png" alt=""></p>
<p>When we want to search for <code>key100</code>, we start by computing its hash value and finding that it maps to bucket 5. We then traverse the linked list in bucket 5, comparing each key until we find <code>key100</code>. This is how chained hashing allows us to resolve collisions and locate the desired entry.</p>
<p>However, there is a drawback to chained hashing. As the linked list in a single bucket grows longer, the time it takes to search for a key in that bucket increases, which can degrade the overall performance of the hash table.</p>
<p>So, is there a way to minimize the performance impact? Yes! That brings us to the next topic: the design and implementation of <em>rehashing</em>.</p>
<h2 id="How-does-Redis-Implement-Rehashing"><a href="#How-does-Redis-Implement-Rehashing" class="headerlink" title="How does Redis Implement Rehashing?"></a>How does Redis Implement Rehashing?</h2><p>Rehashing in Redis essentially refers to expanding the size of the hash table. The basic approach Redis takes to implement rehashing is as follows:</p>
<ol>
<li><strong>Redis uses two hash tables alternately during rehashing</strong>. As I mentioned earlier, Redis defines the hash table using the <code>dictht</code> structure in <code>dict.h</code>. However, when actually using the hash table, Redis also defines a <code>dict</code> structure in the same file. This structure contains an array (<code>ht[2]</code>) with two hash tables: <code>ht[0]</code> and <code>ht[1]</code>. The <code>dict</code> structure is defined in the code as follows:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>During normal operation, all key-value pairs are written to</strong> <code>ht[0]</code>.</li>
<li><strong>When rehashing occurs</strong>, key-value pairs are gradually migrated from <code>ht[0]</code> to <code>ht[1]</code>.</li>
<li><strong>After migration is complete</strong>, the memory space of <code>ht[0]</code> is released, and the address of <code>ht[1]</code> is assigned to <code>ht[0]</code>. Then, the size of <code>ht[1]</code> is reset to zero. At this point, Redis resumes normal operations, with <code>ht[0]</code> handling requests and <code>ht[1]</code> reserved for the next rehash.</li>
</ol>
<p>To help you understand this alternating process between <code>ht[0]</code> and <code>ht[1]</code>, I’ve included a diagram below.</p>
<p><img src="/image/redis-src/2024091104.png" alt=""></p>
<p>Now that you have a basic understanding of how Redis alternates between two hash tables to implement rehashing, let’s discuss some important questions that need to be addressed during rehashing. I believe there are three key issues to consider:</p>
<ol>
<li><strong>When should rehashing be triggered?</strong></li>
<li><strong>How much should the hash table be expanded?</strong></li>
<li><strong>How should rehashing be carried out?</strong></li>
</ol>
<p>Next, I’ll walk you through the code implementation for each of these questions, so you can clearly see how Redis handles these aspects of rehashing.</p>
<h3 id="When-Should-Rehashing-Be-Triggered"><a href="#When-Should-Rehashing-Be-Triggered" class="headerlink" title="When Should Rehashing Be Triggered?"></a>When Should Rehashing Be Triggered?</h3><p>To determine when rehashing is needed, Redis uses the function <code>_dictExpandIfNeeded</code>. Let’s first look at the conditions within this function that trigger resizing, and then explore where this function is called in the Redis codebase.</p>
<p>There are three conditions defined in the <code>_dictExpandIfNeeded</code> function that can trigger expansion:</p>
<ol>
<li><strong>Condition 1</strong>: The size of <code>ht[0]</code> is zero.</li>
<li><strong>Condition 2</strong>: The number of elements in <code>ht[0]</code> exceeds its current size, and the hash table can be resized.</li>
<li><strong>Condition 3</strong>: The number of elements in <code>ht[0]</code> is a multiple of the table size, defined by <code>dict_force_resize_ratio</code> (which defaults to 5).</li>
</ol>
<p>Here’s a snippet of the code defining these conditions in the <code>_dictExpandIfNeeded</code> function:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictTypeExpandAllowed(d))</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    <span class="keyword">if</span> ((dict_can_resize == DICT_RESIZE_ENABLE &amp;&amp;</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size) ||</span><br><span class="line">        (dict_can_resize != DICT_RESIZE_FORBID &amp;&amp;</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used / d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For the first condition, if the hash table is empty, Redis simply sets the table to its initial size, which is part of initialization, not rehashing. </p>
<p>Conditions two and three, however, correspond to rehashing scenarios. In both cases, Redis compares the number of elements in the hash table (<code>d-&gt;ht[0].used</code>) with the table’s current size (<code>d-&gt;ht[0].size</code>). This ratio is known as the <strong>load factor</strong>. Redis triggers rehashing when the load factor is either equal to or greater than 1, or greater than 5.</p>
<p>When the load factor exceeds 5, it indicates that the hash table is severely overloaded and needs to be resized immediately. If the load factor is 1 or greater, Redis checks the value of the variable <code>dict_can_resize</code> to determine if resizing is currently allowed.</p>
<p>You may wonder, what exactly is the <code>dict_can_resize</code> variable? This variable is controlled by two functions: <code>dictEnableResize</code> and <code>dictDisableResize</code>, which enable and disable hash table resizing, respectively:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dictEnableResize</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictDisableResize</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These functions are wrapped within <code>updateDictResizePolicy</code>. This function enables or disables rehashing based on whether Redis is currently running an RDB snapshot or AOF rewrite process. If neither process is running, rehashing is allowed:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">updateDictResizePolicy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</span><br><span class="line">        dictEnableResize();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dictDisableResize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now that we understand the conditions for triggering rehashing in <code>_dictExpandIfNeeded</code>, let’s look at where this function is called in Redis. By examining the <code>dict.c</code> file, we can see that <code>_dictExpandIfNeeded</code> is invoked by the <code>_dictKeyIndex</code> function, which is itself called by <code>dictAddRaw</code>. The <code>dictAddRaw</code> function is then called by three key functions:</p>
<ol>
<li><code>dictAdd</code>: Adds a key-value pair to the hash table.</li>
<li><code>dictReplace</code>: Adds a key-value pair or replaces an existing one.</li>
<li><code>dictAddOrFind</code>: Calls <code>dictAddRaw</code> directly.</li>
</ol>
<p>Thus, every time Redis adds or modifies a key-value pair, it checks whether rehashing is necessary. The following diagram illustrates the call relationships leading to <code>_dictExpandIfNeeded</code>.</p>
<p><img src="/image/redis-src/2024091105.png" alt=""></p>
<p>In summary, the key functions responsible for triggering rehashing in Redis are <code>_dictExpandIfNeeded</code> and <code>updateDictResizePolicy</code>. The former checks the load factor and whether resizing is allowed, while the latter enables or disables resizing based on RDB and AOF processes.</p>
<p>Next, we’ll explore the second major question in rehashing: <strong>how much should Redis expand the hash table?</strong></p>
<h3 id="How-Much-Should-the-Hash-Table-Be-Expanded"><a href="#How-Much-Should-the-Hash-Table-Be-Expanded" class="headerlink" title="How Much Should the Hash Table Be Expanded?"></a>How Much Should the Hash Table Be Expanded?</h3><p>In Redis, when resizing the hash table space due to rehashing, it calls the <code>**dictExpand**</code> function. This function takes two parameters: the hash table to be resized (<code>**dict *d**</code>) and the target size (<code>**unsigned long size**</code>). The prototype of the <code>**dictExpand**</code> function is shown below:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>To determine whether resizing is needed for a hash table, we use the <code>**_dictExpandIfNeeded**</code> function. Once resizing is deemed necessary, Redis expands the hash table during rehashing by doubling its current size (<code>**size * 2**</code>) if the current table’s used space is <code>**size**</code>, as illustrated in the following code snippet:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>The actual resizing process in the <code>**dictExpand**</code> function is managed by the <code>**_dictNextPower**</code> function. This function continuously doubles the hash table’s initial size (<code>**DICT_HT_INITIAL_SIZE**</code>) until it reaches the target size, as shown in the code snippet below:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> _dictNextPower(<span class="type">unsigned</span> <span class="type">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX + <span class="number">1LU</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, let’s delve into Redis’s approach to addressing the third issue: how to execute rehashing. Essentially, this involves Redis implementing a incremental rehashing design.</p>
<h3 id="How-is-Incremental-Rehashing-Implemented"><a href="#How-is-Incremental-Rehashing-Implemented" class="headerlink" title="How is Incremental Rehashing Implemented?"></a>How is Incremental Rehashing Implemented?</h3><p>First, let’s clarify why we need incremental rehashing in the first place. When a hash table undergoes rehashing, the hash table space expands, and keys that were mapped to certain positions may now need to be relocated to new ones. This means many keys must be copied from their old positions to new ones. During this key copying process, Redis’s main thread is unable to handle other requests, causing the rehashing process to block the main thread and lead to performance overhead.</p>
<p>To mitigate this overhead, Redis introduced the concept of incremental rehashing.</p>
<p>In simple terms, incremental rehashing means Redis doesn’t copy all the keys from the current hash table to the new one in a single operation. Instead, it copies them in batches, with each operation only transferring keys from one bucket at a time. This limits the duration of each copying operation, thereby reducing its impact on the main thread.</p>
<p>So, how is incremental rehashing implemented in the code? There are two key functions involved: <code>dictRehash</code> and <code>_dictRehashStep</code>.</p>
<p>Let’s start with the <code>dictRehash</code> function, which performs the actual key copying. It takes two input parameters: the global hash table (which consists of the <code>dict</code> structure holding <code>ht[0]</code> and <code>ht[1]</code>) and the number of buckets to be rehashed.</p>
<p>The logic of the <code>dictRehash</code> function is divided into two parts:</p>
<ol>
<li>First, it runs a loop, copying the keys in each bucket according to the specified number of buckets <code>n</code>. Of course, if all the data in <code>ht[0]</code> has already been transferred, the copying loop stops.</li>
<li>Second, after copying <code>n</code> buckets, the function checks whether all the data in <code>ht[0]</code> has been migrated. If so, the space for <code>ht[0]</code> is released. Since Redis always references <code>ht[0]</code> when handling requests, once the rehashing process is complete and the data is fully in <code>ht[1]</code>, Redis assigns <code>ht[1]</code> to <code>ht[0]</code>, ensuring that other parts of the code can continue functioning as expected. After this, the size of <code>ht[1]</code> is reset to zero in preparation for the next rehash. At the same time, the global hash table’s <code>rehashidx</code> variable is set to -1, indicating that the rehash process has finished (I’ll explain the purpose of the <code>rehashidx</code> variable shortly).</li>
</ol>
<p>Here’s a diagram that illustrates the primary steps of the <code>dictRehash</code> function. </p>
<p><img src="/image/redis-src/2024091106.png" alt=""></p>
<p>You can also check the code snippet below to better understand its logic.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s0 = d-&gt;ht[<span class="number">0</span>].size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s1 = d-&gt;ht[<span class="number">1</span>].size;</span><br><span class="line">    <span class="keyword">if</span> (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dict_can_resize == DICT_RESIZE_AVOID &amp;&amp; </span><br><span class="line">        ((s1 &gt; s0 &amp;&amp; s1 / s0 &lt; dict_force_resize_ratio) ||</span><br><span class="line">         (s1 &lt; s0 &amp;&amp; s0 / s1 &lt; dict_force_resize_ratio)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now that we’ve covered the core functionality of the <code>dictRehash</code> function, let’s explore how incremental rehashing works by migrating data at the bucket level. This is where the <code>rehashidx</code> variable in the global hash table structure comes into play.</p>
<p>The <code>rehashidx</code> variable indicates which bucket is currently being migrated. For instance, when <code>rehashidx</code> is 0, the first bucket in <code>ht[0]</code> is being migrated; when it’s 1, the second bucket is being migrated, and so on.</p>
<p>The main loop in the <code>dictRehash</code> function checks whether the bucket pointed to by <code>rehashidx</code> is empty. If it is, <code>rehashidx</code> is incremented, and the next bucket is examined.</p>
<p>But is it possible for multiple consecutive buckets to be empty? Yes, it is. In such cases, incremental rehashing doesn’t just keep incrementing <code>rehashidx</code> indefinitely. The reason is that during rehashing, the Redis main thread is unable to handle other requests. Therefore, Redis introduces a variable called <code>empty_visits</code> to track how many empty buckets have been checked. After a certain number of empty buckets have been examined, the current round of rehashing stops, allowing Redis to process external requests and avoid performance degradation. You can see this logic in the code snippet below.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    d-&gt;rehashidx++;</span><br><span class="line">    <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If the bucket that <code>rehashidx</code> points to contains data for migration, Redis will take each hash entry from that bucket, recalculate its new position in <code>ht[1]</code> based on the size of <code>ht[1]</code>, and insert the hash entry into the appropriate bucket in <code>ht[1]</code>. Each time a hash entry is migrated, the <code>used</code> variables in <code>ht[0]</code> and <code>ht[1]</code> (which track how many entries each table holds) are updated—<code>used</code> in <code>ht[0]</code> decreases by one, while <code>used</code> in <code>ht[1]</code> increases by one. Once all data in the current bucket is migrated, <code>rehashidx</code> is incremented, and the process continues with the next bucket. The code snippet below illustrates this migration process.</p>
<p>By now, we’ve covered the complete logic of the <code>dictRehash</code> function. We know that <code>dictRehash</code> migrates hash entries on a bucket-by-bucket basis, with the number of buckets processed being determined by the loop count parameter <code>n</code>. Whenever Redis performs a rehash operation, it eventually calls the <code>dictRehash</code> function.</p>
<p>Next, let’s look at the second key function involved in incremental rehashing: <code>_dictRehashStep</code>, which performs rehashing one bucket at a time. According to Redis’s source code, there are five functions that call <code>_dictRehashStep</code>, which in turn calls <code>dictRehash</code> to carry out the rehashing process. These functions are: <code>dictAddRaw</code>, <code>dictGenericDelete</code>, <code>dictFind</code>, <code>dictGetRandomKey</code>, and <code>dictGetSomeKeys</code>.</p>
<p>The functions <code>dictAddRaw</code> and <code>dictGenericDelete</code> are used to add and delete key-value pairs in Redis, while the other three functions are for querying. The diagram below shows the relationships between these functions.</p>
<p><img src="/image/redis-src/2024091107.png" alt=""></p>
<p>It’s important to note that regardless of whether you’re adding, deleting, or querying, when these five functions call <code>_dictRehashStep</code>, the loop count parameter <code>n</code> passed to <code>dictRehash</code> is always set to 1, as shown in the following code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="comment">// Passes 1 as the loop count parameter to `dictRehash`, meaning that after migrating one bucket, normal operations resume</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This means that after migrating a single bucket, the hash table is free to handle regular add, delete, or query operations. This is how incremental rehashing is implemented at the code level.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Creating a high-performance hash table is not only a priority for Redis but also a crucial goal in the development of many computer systems. To build an efficient hash table, two key issues need to be addressed: hash collisions and the overhead of rehashing.</p>
<p>In this article, we explored the structure of Redis’s hash table, the implementation of chained hashing, and the design and implementation of incremental rehashing. Redis’s hash table structure is unique—each hash entry contains a pointer, enabling chained hashing. Additionally, Redis uses a global hash table that contains two hash tables, a design that facilitates data migration from one table to another during rehashing.</p>
<p>The incremental rehashing mechanism in Redis is a general method for hash table expansion and is worth studying. Its core idea is to migrate only a limited number of buckets at a time, preventing performance issues that arise from migrating all buckets in one go. Once you understand the concept and implementation of incremental rehashing, you can apply it to your own hash table designs.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com">Johnson Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://linjiangxiong.com/2024/09/11/analyzing-redis-source-code-hash/">http://linjiangxiong.com/2024/09/11/analyzing-redis-source-code-hash/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="/image/redis-src/2024091101.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/10/analyzing-redis-source-code-sds/" title="Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation"><img class="cover" src="/image/redis-src/24091002.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Analyzing Redis Source Code: Simple Dynamic Strings (SDS) – An Efficient and Flexible String Implementation</div></div><div class="info-2"><div class="info-item-1">Redis’s Requirements for StringsStrings are an essential data type in app development, frequently used to store a variety of information such as user profiles, product descriptions, and system messages. In Redis, a popular in-memory data store, both the keys and often the values in key-value pairs are represented as strings. This makes strings one of the foundational data types in Redis, contributing to its flexibility and simplicity when handling data.  For instance, when saving user data...</div></div></div></a><a class="pagination-related" href="/2024/09/18/bulk-deleting-keys-in-redis-using-wildcards/" title="Bulk Deleting Keys in Redis Using Wildcards"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Bulk Deleting Keys in Redis Using Wildcards</div></div><div class="info-2"><div class="info-item-1">          Be Cautious with the KEYS Command in Production: Commands like KEYS, FLUSHALL, and FLUSHDB can block Redis when working with large datasets. They may scan the entire keyspace, potentially locking up Redis and degrading performance.    Redis currently does not support bulk deletion of keys using wildcards. However, we can achieve this using the del command in combination with Linux pipes and the xargs command. The del command in Redis allows you to delete one or more specified keys...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2019/09/03/redis-batch-delete/" title="Redis根据通配符批量删除Key"><img class="cover" src="https://i.loli.net/2021/07/19/4eRMmKi3gvOHFlf.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-03</div><div class="info-item-2">Redis根据通配符批量删除Key</div></div><div class="info-2"><div class="info-item-1">Redis 目前还不支持根据通配符批量删除 Key 的命令，但我们可以借助 Redis 的 del 命令、Linux 管道和 xargs 指令来完成。  Redis的 del 命令支持删除给定的一个或多个 key，并返回被删除 key 的数量。如命令 del key1 key2 key3。  比如要删除所有以 WxMpSessionKey 开头的 Key，可以使用如下命令： 12[redis@iztz9ploifbvce ~]# redis-cli -h 192.168.182.227 -p 1379 keys &quot;WxMpSessionKey*&quot; |xargs redis-cli -h 192.168.182.227 -p 1379 del(integer) 2674 如果连接 Redis 的 HOST 为 127.0.0.1，端口号也为默认的 6379，则以上的命令可以简写为： 1redis-cli keys &quot;WxMpSessionKey*&quot; |xargs redis-cli del （END） </div></div></div></a><a class="pagination-related" href="/2019/12/19/spring-boot-2_x-redis/" title="Spring Boot 2.x 集成Redis示例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-19</div><div class="info-item-2">Spring Boot 2.x 集成Redis示例</div></div><div class="info-2"><div class="info-item-1">一、如何集成首先，在 pom 文件新增 redis 依赖： 1234&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 接着修改项目配置文件 application.properties，增加 redis 配置 1234# redis hostspring.redis.host=172.24.58.226# redis portspring.redis.port=6379 经过上面简单的两步，即可在项目中使用 StringRedisTemplate 和 RedisTemplate&lt;Object,Object&gt;，因为从 Spring Boot 2.0 开始，Spring...</div></div></div></a><a class="pagination-related" href="/2024/06/02/using-the-pfadd-command-in-redis/" title="Using the PFADD Command in Redis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="info-item-2">Using the PFADD Command in Redis</div></div><div class="info-2"><div class="info-item-1">Redis, an open-source, in-memory data structure store, offers a wide range of commands to manipulate data structures like strings, lists, sets, hashes, bitmaps, hyperloglogs, and more. Among these, the HyperLogLog data type is particularly useful for approximating the number of unique elements in a set when the set is too large to fit into memory or when you don’t need absolute accuracy. The PFADD command is one of the key operations for working with HyperLogLog in Redis. This guide will...</div></div></div></a><a class="pagination-related" href="/2024/07/25/how-to-learn-redis-effectively/" title="How to learn Redis effectively?"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-25</div><div class="info-item-2">How to learn Redis effectively?</div></div><div class="info-2"><div class="info-item-1">Redis, an open-source, high-performance in-memory data structure store, is renowned for its speed, versatility, and simplicity. It has gained immense popularity and is widely utilized for caching, distributed locks, session management, real-time analytics, and more. Whether you’re a developer looking to expand your skills or an IT professional aiming to optimize data handling, mastering Redis can significantly enhance your proficiency. Here’s a comprehensive guide on how to learn Redis...</div></div></div></a><a class="pagination-related" href="/2024/07/27/flushing-cache-data-in-redis-a-step-by-step-guide/" title="Flushing Cache Data in Redis: A Step-by-Step Guide"><img class="cover" src="/image/2024/07/2024072701.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="info-item-2">Flushing Cache Data in Redis: A Step-by-Step Guide</div></div><div class="info-2"><div class="info-item-1">Caching mechanisms are vital for optimizing application performance by storing frequently accessed data in-memory. Redis, as a robust key-value store, offers powerful caching capabilities. Occasionally, you might need to clear or flush all cached data from Redis to ensure consistency or during maintenance tasks. Here’s how you can do it effectively:  Understanding Redis FlushingFlushing in Redis refers to the action of removing all data stored in the current database. This operation is...</div></div></div></a><a class="pagination-related" href="/2024/07/30/effective-ways-to-delete-fuzzy-matching-keys-in-redis/" title="Effective Ways to Delete Fuzzy Matching Keys in Redis"><img class="cover" src="/image/2024/07/fuzzy-matching.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-30</div><div class="info-item-2">Effective Ways to Delete Fuzzy Matching Keys in Redis</div></div><div class="info-2"><div class="info-item-1">In Redis, managing keys efficiently is crucial for optimal performance. Sometimes, you might need to delete keys that match a pattern or have a fuzzy match. Here’s how you can achieve this: Using Redis CLI CommandsRedis CLI provides several commands to interact with keys. To delete keys that match a pattern, you can use the KEYS command in combination with the DEL command: 1redis-cli KEYS &quot;pattern*&quot; | xargs redis-cli DEL Replace &quot;pattern*&quot; with your specific pattern. This...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/IMG_3665.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Johnson Lin</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">488</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iuiuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/iuiuu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:me@linjiangxiong.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#How-does-Redis-Implement-Chained-Hashing"><span class="toc-number">1.</span> <span class="toc-text">How does Redis Implement Chained Hashing?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-a-Hash-Collision"><span class="toc-number">1.1.</span> <span class="toc-text">What is a Hash Collision?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-is-Chained-Hashing-Designed-and-Implemented"><span class="toc-number">1.2.</span> <span class="toc-text">How is Chained Hashing Designed and Implemented?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-does-Redis-Implement-Rehashing"><span class="toc-number">2.</span> <span class="toc-text">How does Redis Implement Rehashing?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#When-Should-Rehashing-Be-Triggered"><span class="toc-number">2.1.</span> <span class="toc-text">When Should Rehashing Be Triggered?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-Much-Should-the-Hash-Table-Be-Expanded"><span class="toc-number">2.2.</span> <span class="toc-text">How Much Should the Hash Table Be Expanded?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-is-Incremental-Rehashing-Implemented"><span class="toc-number">2.3.</span> <span class="toc-text">How is Incremental Rehashing Implemented?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">3.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/06/how-to-run-deepseek-locally-on-windows/" title="How To Run DeepSeek Locally On Windows?">How To Run DeepSeek Locally On Windows?</a><time datetime="2025-02-05T18:27:11.000Z" title="Created 2025-02-06 02:27:11">2025-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/ollama-python-sdk/" title="Using Ollama with Python">Using Ollama with Python</a><time datetime="2025-01-29T07:17:04.000Z" title="Created 2025-01-29 15:17:04">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/ollama-api/" title="Interacting with the Ollama API">Interacting with the Ollama API</a><time datetime="2025-01-29T06:01:52.000Z" title="Created 2025-01-29 14:01:52">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/ollama-cli/" title="Interacting with Ollama Models">Interacting with Ollama Models</a><time datetime="2025-01-29T05:06:06.000Z" title="Created 2025-01-29 13:06:06">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/ollama-core-concepts/" title="Ollama Core Concepts">Ollama Core Concepts</a><time datetime="2025-01-29T04:11:16.000Z" title="Created 2025-01-29 12:11:16">2025-01-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Johnson Lin</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/main.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>